//! Generators for the models usd in the Nexmark benchmark suite.
//!
//! Based on the equivalent [Nexmark Flink generator API](https://github.com/nexmark/nexmark/blob/v0.2.0/nexmark-flink/src/main/java/com/github/nexmark/flink/generator).

use self::config::Config;
use super::model::Event;
use bids::CHANNELS_NUMBER;
use cached::SizedCache;
use rand::Rng;

mod auctions;
mod bids;
pub mod config;
mod people;
mod price;
mod strings;

pub struct NexmarkGenerator<R: Rng> {
    /// Configuration to generate events against.
    config: Config,
    rng: R,

    /// The memory cache used when creating bid channels.
    bid_channel_cache: SizedCache<u32, (String, String)>,

    /// Number of events generated by this generator.
    /// Note that when there are multiple generators working in parallel, the
    /// events count for each generator is less than the events generated by the
    /// source.
    events_count_so_far: u64,
}

impl<R: Rng> Iterator for NexmarkGenerator<R> {
    type Item = Event;

    fn next(&mut self) -> Option<Event> {
        let new_event_id = self.config.next_event_number(self.events_count_so_far);
        if new_event_id >= self.config.max_events {
            return None;
        }

        // When, in event time, we should generate the event. Monotonic.
        let event_timestamp = self.config.timestamp_for_event(new_event_id);

        let (auction_proportion, person_proportion, total_proportion) = (
            self.config.options.auction_proportion as u64,
            self.config.options.person_proportion as u64,
            self.config.options.total_proportion() as u64,
        );

        let rem = new_event_id % total_proportion;
        let event = if rem < person_proportion {
            Event::Person(self.next_person(new_event_id, event_timestamp))
        } else if rem < person_proportion + auction_proportion {
            Event::Auction(self.next_auction(new_event_id, event_timestamp))
        } else {
            Event::Bid(self.next_bid(new_event_id, event_timestamp))
        };

        self.events_count_so_far += 1;
        Some(event)
    }
}

impl<R: Rng> NexmarkGenerator<R> {
    pub fn new(config: Config, rng: R) -> NexmarkGenerator<R> {
        NexmarkGenerator {
            config,
            rng,
            bid_channel_cache: SizedCache::with_size(CHANNELS_NUMBER as usize),
            events_count_so_far: 0,
        }
    }
}

#[cfg(test)]
pub mod tests {
    use super::*;
    use crate::{
        config::GeneratorOptions,
        model::{Auction, Bid, Person},
    };
    use rand::{rngs::mock::StepRng, thread_rng};
    use rstest::rstest;

    pub fn make_test_generator() -> NexmarkGenerator<StepRng> {
        NexmarkGenerator::new(
            Config {
                options: GeneratorOptions {
                    num_event_generators: 1,
                    ..GeneratorOptions::default()
                },
                ..Config::default()
            },
            StepRng::new(0, 1),
        )
    }

    pub fn make_person() -> Person {
        Person {
            id: 1,
            name: String::from("AAA BBBB"),
            email_address: String::from("AAABBB@example.com"),
            credit_card: String::from("1111 2222 3333 4444"),
            city: String::from("Phoenix"),
            state: String::from("OR"),
            date_time: 0,
            extra: String::from(""),
        }
    }

    pub fn make_bid() -> Bid {
        Bid {
            auction: 1,
            bidder: 1,
            price: 99,
            channel: String::from("my-channel"),
            url: String::from("https://example.com"),
            date_time: 0,
            extra: String::new(),
        }
    }

    pub fn make_auction() -> Auction {
        Auction {
            id: 1,
            item_name: String::from("item-name"),
            description: String::from("description"),
            initial_bid: 5,
            reserve: 10,
            date_time: 0,
            expires: 2000,
            seller: 1,
            category: 1,
            extra: String::new(),
        }
    }

    pub fn make_next_event() -> Event {
        Event::Bid(make_bid())
    }

    /// Generates a specified number of next events using the default test
    /// generator.
    pub fn generate_expected_next_events(num_events: usize) -> Vec<Option<Event>> {
        let mut ng = make_test_generator();

        (0..num_events).map(|_| ng.next()).collect()
    }

    #[test]
    fn test_has_next() {
        let mut ng = make_test_generator();
        ng.config.max_events = 2;

        ng.next().unwrap();
        ng.next().unwrap();
        assert!(ng.next().is_none());
    }

    #[rstest]
    #[case::single_generator_start_zero(1, 0, vec![0, 1, 2])]
    #[case::first_of_three_generators_start_0(3, 0, vec![0, 3, 6, 9])]
    #[case::third_of_three_generators_start_0(3, 2, vec![2, 5, 8, 11])]
    fn test_next_event_id(
        #[case] num_event_generators: usize,
        #[case] first_event_number: usize,
        #[case] expected_next_event_ids: Vec<u64>,
    ) {
        let config = Config {
            options: GeneratorOptions {
                num_event_generators,
                ..GeneratorOptions::default()
            },
            first_event_number,
            ..Config::default()
        };
        let mut generator = NexmarkGenerator::new(config.clone(), StepRng::new(0, 1));

        for (num_events, expected_id) in expected_next_event_ids.into_iter().enumerate() {
            assert_eq!(config.next_event_number(num_events as u64), expected_id);
            generator.next().unwrap();
        }
    }

    // Tests the first five expected events without relying on any test
    // helper for the data.
    #[test]
    fn test_next_event() {
        let mut ng = NexmarkGenerator::new(
            Config {
                options: GeneratorOptions {
                    num_event_generators: 1,
                    ..GeneratorOptions::default()
                },
                ..Config::default()
            },
            thread_rng(),
        );

        // The first event with the default config is the person
        let next_event = ng.next();
        assert!(next_event.is_some());
        let next_event = next_event.unwrap();

        assert!(
            matches!(next_event, Event::Person(_)),
            "got: {:?}, want: Event::NewPerson(_)",
            next_event
        );
        assert_eq!(next_event.timestamp(), 0);

        // The next 3 events with the default config are auctions
        for event_num in 1..=3 {
            let next_event = ng.next();
            assert!(next_event.is_some());
            let next_event = next_event.unwrap();

            assert!(
                matches!(next_event, Event::Auction(_)),
                "got: {:?}, want: Event::NewAuction(_)",
                next_event
            );
            assert_eq!(next_event.timestamp(), event_num * 10);
        }

        // And the rest of the events in the first epoch are bids.
        for _ in 4..=49 {
            let next_event = ng.next();
            assert!(next_event.is_some());
            let next_event = next_event.unwrap();

            assert!(
                matches!(next_event, Event::Bid(_)),
                "got: {:?}, want: Event::NewBid(_)",
                next_event
            );
        }

        // The next epoch begins with another person etc.
        let next_event = ng.next().unwrap();
        assert!(
            matches!(next_event, Event::Person(_)),
            "got: {:?}, want: Event::NewPerson(_)",
            next_event
        );
    }

    // Verifies that the `generate_expected_next_events()` test helper does
    // indeed output predictable results matching the order verified manually in
    // the above `test_next_events` (at least for the first 5 events).  Together
    // with the manual test above of next_events, this ensures the order is
    // correct for external call-sites.
    #[test]
    fn test_generate_expected_next_events() {
        let mut ng = make_test_generator();

        let expected_events = generate_expected_next_events(100);

        assert_eq!(
            (0..100).map(|_| ng.next()).collect::<Vec<Option<Event>>>(),
            expected_events
        );
    }
}
