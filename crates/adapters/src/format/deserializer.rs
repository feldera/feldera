use serde::{Deserialize, Serialize};

// TODO: make parsing configurable, e.g., with a subset of columns.

/// Deserialization error type that includes field name,
/// which failed to parse correctly.
#[derive(Debug, Serialize, Deserialize, PartialEq, Eq)]
pub struct FieldParseError {
    pub field: String,
    pub description: String,
}

/// Generate an `impl Deserialize` for a SQL table row type.
///
/// A call to this macro is normally generated by the SQL compiler.
///
/// Generate an `impl Deserialize` for a struct with two twists (compared to the default
/// implementation produced by `serde-derive`):
/// - Supports case-insensitive parsing of field names.
/// - On error, reports the name of the field that failed to parse.
#[macro_export]
macro_rules! deserialize_table_record {
    ($table:ident[$sql_table:tt, $num_cols:expr]{$(($field_name:ident, $column_name:tt, $case_sensitive:tt, $type:ty, $init:expr)),* }) => {
        #[allow(non_snake_case)]
        #[allow(unused_variables)]
        #[allow(unused_mut)]
        impl<'de> serde::Deserialize<'de> for $table {
            fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct RecordVisitor;
                impl<'de> serde::de::Visitor<'de> for RecordVisitor {
                    type Value = $table;

                    fn expecting(&self, formatter: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                        write!(formatter, concat!("a record of type ", stringify!($table)))
                    }

                    fn visit_map<A>(self, mut map: A) -> Result<Self::Value, A::Error>
                    where A: serde::de::MapAccess<'de> {
                        $(let mut $field_name: Option<$type> = $init;
                        )*

                        while let Some(column_name) = map.next_key::<std::borrow::Cow<'de, str>>()? {
                            let uppercase_column_name = column_name.to_uppercase();
                            $(
                                if $column_name == (if $case_sensitive { column_name.as_ref() } else { &uppercase_column_name } ) {
                                    // We don't have a way to return `FieldParseError` to the
                                    // user, since the error type is determined by the
                                    // deserializer type `D`, so we instead encode it as a JSON
                                    // object, which the client will have to parse.
                                    $field_name = Some(map.next_value::<$type>()
                                                  .map_err(|e| serde::de::Error::custom(serde_json::to_string(&$crate::format::FieldParseError{field: $column_name.to_string(), description: e.to_string()}).unwrap()))?);
                                } else
                            )*
                            {let _ = map.next_value::<serde::de::IgnoredAny>()?;}
                        }
                        Ok($table {
                            $($field_name: $field_name.ok_or_else(|| serde::de::Error::missing_field($column_name))?,
                            )*
                        })
                    }

                    fn visit_seq<A>(self, mut seq: A) -> Result<Self::Value, A::Error>
                    where A: serde::de::SeqAccess<'de> {
                        let mut _cols: usize = 0;
                        let result = $table {
                            $($field_name: {
                                _cols += 1;
                                seq.next_element::<$type>()
                                    .map_err(|e| {
                                        serde::de::Error::custom(serde_json::to_string(&$crate::format::FieldParseError{field: $column_name.to_string(), description: e.to_string()}).unwrap())
                                    })?
                                    .ok_or_else(|| {
                                        serde::de::Error::invalid_length(_cols-1, &format!("{} columns", $num_cols).as_str())
                                    })?
                            },
                            )*
                        };

                        while seq.next_element::<serde::de::IgnoredAny>()?.is_some() {}

                        Ok(result)
                    }
                }

                let visitor = RecordVisitor;

                // XXX: At least with `serde_json::Deserializer`, `deserialize_struct` tells the
                // deserializer to work with either map or sequence representation
                // (while `deserialize_map` only deserializes from a map).  It seems that
                // `serde_json` ignores the actual field names provided, so this does not
                // break the case-insensitive behavior.  Not sure if this is true for all
                // deserializers.  In the future we may want to make the choice between map
                // and sequence representations configurable, so we won't need this trick.
                //deserializer.deserialize_map(visitor)
                deserializer.deserialize_struct($sql_table, [$($column_name,)*].as_slice(), visitor)
            }
        }
    }
}

#[cfg(test)]
mod test {
    use dbsp::algebra::F64;

    #[derive(Debug, Eq, PartialEq)]
    struct TUPLE0;
    deserialize_table_record!(TUPLE0["EmptyTable", 0] {});

    #[test]
    fn deserialize_unit() {
        assert_eq!(serde_json::from_str::<TUPLE0>("{}").unwrap(), TUPLE0);
        assert_eq!(
            serde_json::from_str::<TUPLE0>(r#"{"extra_field": 5}"#).unwrap(),
            TUPLE0
        );
        assert_eq!(serde_json::from_str::<TUPLE0>("[]").unwrap(), TUPLE0);
    }

    #[derive(Debug, Eq, PartialEq)]
    #[allow(non_snake_case)]
    struct Struct2 {
        #[allow(non_snake_case)]
        CC_NUM: F64,
        #[allow(non_snake_case)]
        FIRST: Option<String>,
    }
    deserialize_table_record!(Struct2["Table.Name", 2] {(CC_NUM, "CC_NUM", false, F64, None), (FIRST, "FIRST", false, Option<String>, Some(None)) });

    #[test]
    fn deserialize_struct2() {
        assert_eq!(
            serde_json::from_str::<Struct2>(r#"{"cc_num": 100}"#).unwrap(),
            Struct2 {
                CC_NUM: F64::from(100),
                FIRST: None
            }
        );
        assert_eq!(
            serde_json::from_str::<Struct2>(r#"{"CC_NUM": 100, "first": null}"#).unwrap(),
            Struct2 {
                CC_NUM: F64::from(100),
                FIRST: None
            }
        );
        assert_eq!(
            serde_json::from_str::<Struct2>(r#"{"CC_NUM": 100, "first": "foo"}"#).unwrap(),
            Struct2 {
                CC_NUM: F64::from(100),
                FIRST: Some("foo".to_string())
            }
        );
        assert_eq!(
            serde_json::from_str::<Struct2>(r#"{"first": "foo"}"#).map_err(|e| e.to_string()),
            Err(r#"missing field `CC_NUM` at line 1 column 16"#.to_string())
        );
        assert_eq!(
            serde_json::from_str::<Struct2>(r#"[100, "foo"]"#).unwrap(),
            Struct2 {
                CC_NUM: F64::from(100),
                FIRST: Some("foo".to_string())
            }
        );
        assert_eq!(
            serde_json::from_str::<Struct2>(r#"[100, null]"#).unwrap(),
            Struct2 {
                CC_NUM: F64::from(100),
                FIRST: None
            }
        );
        assert_eq!(
            serde_json::from_str::<Struct2>(r#"[100, null, "bar"]"#).unwrap(),
            Struct2 {
                CC_NUM: F64::from(100),
                FIRST: None
            }
        );
    }

    #[derive(Debug, Eq, PartialEq)]
    #[allow(non_snake_case)]
    struct CaseSensitive {
        fIeLd1: bool,
        field2: String,
        FIELD3: Option<u8>,
    }

    deserialize_table_record!(CaseSensitive["CaseSensitive", 3] {
        (fIeLd1, "fIeLd1", true, bool, None),
        (field2, "field2", true, String, None),
        (FIELD3, "FIELD3", false, Option<u8>, Some(None))
    });

    #[test]
    fn case_sensitive() {
        assert_eq!(
            serde_json::from_str::<CaseSensitive>(r#"{"fIeLd1": true, "field2": "foo"}"#).unwrap(),
            CaseSensitive {
                fIeLd1: true,
                field2: "foo".to_string(),
                FIELD3: None
            }
        );
        assert_eq!(
            serde_json::from_str::<CaseSensitive>(r#"[true, "foo", 100]"#).unwrap(),
            CaseSensitive {
                fIeLd1: true,
                field2: "foo".to_string(),
                FIELD3: Some(100)
            }
        );
        assert_eq!(
            serde_json::from_str::<CaseSensitive>(r#"{"field1": true, "field2": "foo"}"#)
                .map_err(|e| e.to_string()),
            Err(r#"missing field `fIeLd1` at line 1 column 33"#.to_string())
        );
        assert_eq!(
            serde_json::from_str::<CaseSensitive>(r#"{"fIeLd1": true, "FIELD2": "foo"}"#)
                .map_err(|e| e.to_string()),
            Err(r#"missing field `field2` at line 1 column 33"#.to_string())
        );
    }

    #[test]
    fn error_reporting() {
        // Correctly report parsing errors for individual fields.
        assert_eq!(serde_json::from_str::<CaseSensitive>(r#"{"fIeLd1": 10, "field2": "foo"}"#).map_err(|e| e.to_string()), Err(r#"{"field":"fIeLd1","description":"invalid type: integer `10`, expected a boolean at line 1 column 13"} at line 1 column 13"#.to_string()));
        assert_eq!(serde_json::from_str::<CaseSensitive>(r#"[10, "foo", null]"#).map_err(|e| e.to_string()), Err(r#"{"field":"fIeLd1","description":"invalid type: integer `10`, expected a boolean at line 1 column 3"} at line 1 column 5"#.to_string()));
        assert_eq!(
            serde_json::from_str::<CaseSensitive>(r#"[true]"#).map_err(|e| e.to_string()),
            Err(r#"invalid length 1, expected 3 columns at line 1 column 6"#.to_string())
        );
        assert_eq!(serde_json::from_str::<CaseSensitive>(r#"{"fIeLd1": null, "field2": "foo"}"#).map_err(|e| e.to_string()), Err(r#"{"field":"fIeLd1","description":"invalid type: null, expected a boolean at line 1 column 15"} at line 1 column 15"#.to_string()));
        assert_eq!(serde_json::from_str::<CaseSensitive>(r#"{"fIeLd1": false, "field2": "foo", "FIELD3": true}"#).map_err(|e| e.to_string()), Err(r#"{"field":"FIELD3","description":"invalid type: boolean `true`, expected u8 at line 1 column 49"} at line 1 column 50"#.to_string()));
        assert_eq!(serde_json::from_str::<CaseSensitive>(r#"{"fIeLd1": 10, "field2": "foo"}"#).map_err(|e| e.to_string()), Err(r#"{"field":"fIeLd1","description":"invalid type: integer `10`, expected a boolean at line 1 column 13"} at line 1 column 13"#.to_string()));
    }

    #[derive(Debug, Eq, PartialEq)]
    #[allow(non_snake_case)]
    struct UnicodeStruct {
        f1: bool,
        f2: String,
        f3: Option<u8>,
    }

    deserialize_table_record!(UnicodeStruct["UnicodeStruct", 3] {
        (f1, "αΒβΓγδε", true, bool, None),
        (f2, "УКРАЇНСЬКА", false, String, None),
        (f3, "UNICODE⌛👏", false, Option<u8>, Some(None))
    });

    #[test]
    fn unicode() {
        assert_eq!(
            serde_json::from_str::<UnicodeStruct>(
                r#"{"αΒβΓγδε": true, "Українська": "foo", "unicode⌛👏": 100}"#
            )
            .unwrap(),
            UnicodeStruct {
                f1: true,
                f2: "foo".to_string(),
                f3: Some(100)
            }
        );
        assert_eq!(
            serde_json::from_str::<UnicodeStruct>(
                r#"{"αΒβΓγδε": true, "Українська": 10, "unicode⌛👏": 100}"#
            ).map_err(|e| e.to_string()),
            Err(r#"{"field":"УКРАЇНСЬКА","description":"invalid type: integer `10`, expected a string at line 1 column 51"} at line 1 column 51"#.to_string())
        );
        assert_eq!(
            serde_json::from_str::<UnicodeStruct>(
                r#"[true, 10, 100]"#
            ).map_err(|e| e.to_string()),
            Err(r#"{"field":"УКРАЇНСЬКА","description":"invalid type: integer `10`, expected a string at line 1 column 9"} at line 1 column 11"#.to_string())
        );
    }

    #[test]
    fn csv() {
        let data = r#"true,"foo",5
true,bar,buzz"#;
        let rdr = csv::ReaderBuilder::new()
            .has_headers(false)
            .from_reader(data.as_bytes());
        let mut records = rdr.into_deserialize::<CaseSensitive>();
        assert_eq!(
            records.next().unwrap().unwrap(),
            CaseSensitive {
                fIeLd1: true,
                field2: "foo".to_string(),
                FIELD3: Some(5)
            }
        );
        assert_eq!(records.next().unwrap().map_err(|e| e.to_string()), Err(r#"CSV deserialize error: record 1 (line: 2, byte: 13): {"field":"FIELD3","description":"field 2: invalid digit found in string"}"#.to_string()));
    }
}
