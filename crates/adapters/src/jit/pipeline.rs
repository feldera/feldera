//! A program that JIT-compiles and runs a Feldera pipeline.
//!
//! Inputs:
//! - Dataflow IR generated by the SQL compiler.
//! - SQL program schema generated by the SQL compiler.
//! - Pipeline configuration.
//!
//! Compiles and runs the pipeline as a web server.

use anyhow::Result as AnyResult;
use clap::{Args, Command, FromArgMatches, Parser};
use dataflow_jit::sql_graph::SqlGraph;
use dbsp_adapters::{
    jit::{start_circuit, CircuitConfig, ProgramSchema},
    server::{run_server, ServerArgs},
    CircuitCatalog, ControllerError, DbspCircuitHandle,
};
use std::{fs::File, io::BufReader};

#[derive(Parser, Debug)]
struct JitArgs {
    /// JIT IR file.
    #[arg(short, long)]
    ir: String,
    /// Table schema file.
    #[arg(short, long)]
    schema: String,
    /// Enable JIT optimizer.
    #[arg(short, long)]
    optimize: bool,
    /// Run JIT compiler in release mode.
    #[arg(long)]
    release: bool,
}

/// Compile and run the circuit.
#[allow(clippy::type_complexity)]
fn run(
    workers: usize,
    args: JitArgs,
) -> Result<(Box<dyn DbspCircuitHandle>, Box<dyn CircuitCatalog>), ControllerError> {
    let schema = File::open(&args.schema).map_err(|e| {
        ControllerError::io_error(format!("reading program schema file '{}'", &args.schema), e)
    })?;

    let schema: ProgramSchema = serde_json::from_reader(BufReader::new(schema))
        .map_err(|e| ControllerError::schema_parse_error(&e.to_string()))?;

    let graph = File::open(&args.ir).map_err(|e| {
        ControllerError::io_error(format!("reading program IR file '{}'", &args.ir), e)
    })?;

    let graph = serde_json::from_reader::<_, SqlGraph>(BufReader::new(graph))
        .map_err(|e| ControllerError::ir_parse_error(&e.to_string()))?
        .rematerialize();

    let config = CircuitConfig::default()
        .release(args.release)
        .optimize(args.optimize)
        .workers(workers);

    start_circuit(&schema, graph, config)
}

pub fn main() -> AnyResult<()> {
    let cli = Command::new("Run a Feldera pipeline");
    let cli = JitArgs::augment_args(cli);
    let cli = ServerArgs::augment_args(cli);

    let matches = cli.get_matches();

    let jit_args = JitArgs::from_arg_matches(&matches)?;
    let server_args = ServerArgs::from_arg_matches(&matches)?;

    // Do all input validation and initialization inside `run`, so that all errors can be
    // reported via REST API.
    run_server(server_args, move |workers| run(workers, jit_args))?;

    Ok(())
}
