package org.dbsp.sqlCompiler.compiler.backend.rust;

import org.dbsp.sqlCompiler.circuit.DBSPCircuit;
import org.dbsp.sqlCompiler.circuit.DBSPDeclaration;
import org.dbsp.sqlCompiler.circuit.operator.DBSPOperator;
import org.dbsp.sqlCompiler.circuit.operator.DBSPSourceBaseOperator;
import org.dbsp.sqlCompiler.compiler.DBSPCompiler;
import org.dbsp.sqlCompiler.ir.IDBSPInnerNode;
import org.dbsp.sqlCompiler.ir.IDBSPNode;
import org.dbsp.sqlCompiler.ir.expression.DBSPComparatorExpression;
import org.dbsp.sqlCompiler.ir.expression.DBSPStaticExpression;
import org.dbsp.sqlCompiler.ir.statement.DBSPFunctionItem;
import org.dbsp.util.IndentStream;

import java.io.IOException;

/** Code generator for a circuit which instantiates each operator using a function call
 * generated by a {@link SingleOperatorWriter}. */
public class CircuitWriter extends BaseCodeGenerator {
    CircuitWriter() {}

    void processOperator(DBSPOperator node) {
        DBSPOperator op = node.as(DBSPOperator.class);
        // TODO
    }

    @Override
    public void write(DBSPCompiler compiler) throws IOException {
        assert this.outputStream != null;
        this.outputStream.append(COMMON_PREAMBLE);
        for (String dep: this.dependencies)
            this.outputStream.println("use " + dep + "::*;");
        assert this.toWrite.size() == 1;
        DBSPCircuit circuit = this.toWrite.get(0).to(DBSPCircuit.class);
        IndentStream builder = new IndentStream(this.outputStream);
        ToRustInnerVisitor inner = new ToRustInnerVisitor(compiler, builder, false);

        builder.append("pub fn ")
                .append(circuit.getName())
                .append("Catalog");

        builder
                .append("(cconf: CircuitConfig) -> Result<(DBSPHandle, Catalog), Error> {")
                .increase()
                .newline()
                .append("let (circuit, streams) = Runtime::init_circuit(cconf, |circuit| {")
                .increase();
        builder.append("let mut catalog = Catalog::new();").newline();

        for (DBSPDeclaration item: circuit.declarations) {
            // Generate functions used locally
            if (item.item.is(DBSPFunctionItem.class)) {
                item.accept(inner);
                builder.newline().newline();
            }
        }

        // Process sources first
        for (DBSPOperator node : circuit.getAllOperators())
            if (node.is(DBSPSourceBaseOperator.class))
                this.processOperator(node);

        /*
        ToRustVisitor.FindComparators compFinder = new ToRustVisitor.FindComparators(compiler);
        ToRustVisitor.FindStatics staticsFinder = new ToRustVisitor.FindStatics(compiler);
        compFinder.getCircuitVisitor(false).apply(circuit);
        staticsFinder.getCircuitVisitor(false).apply(circuit);

        for (DBSPComparatorExpression comparator: compFinder.found)
            this.generateCmpFunc(comparator);
        for (DBSPStaticExpression comparator: staticsFinder.found)
            this.generateStatic(comparator);
         */

        for (DBSPOperator node : circuit.getAllOperators())
            if (!node.is(DBSPSourceBaseOperator.class))
                this.processOperator(node);

        builder.append("Ok(catalog)");
        builder.newline()
                .decrease()
                .append("})?;")
                .newline();

        builder
                .append("Ok((circuit, streams))")
                .newline()
                .decrease()
                .append("}")
                .newline();
    }
}
