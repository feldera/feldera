package org.dbsp.sqlCompiler.compiler.backend.rust.multi;

import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.nio.file.Files;

import org.dbsp.sqlCompiler.compiler.DBSPCompiler;
import org.dbsp.sqlCompiler.compiler.backend.rust.RustWriter;
import org.dbsp.sqlCompiler.compiler.errors.CompilationError;
import org.dbsp.sqlCompiler.compiler.errors.UnimplementedException;
import org.dbsp.util.IIndentStream;
import org.dbsp.util.Utilities;

/**
 * This class helps generate Rust code. It is given a set of circuit and
 * functions and generates code in multiple crates. */
public final class MultiCratesWriter extends RustWriter {
    public final String outputDirectory;
    public final String pipelineName;
    File rootDirectory;

    /**
     * Create a writer which will generate code in the specified directory
     */
    public MultiCratesWriter(String outputDirectory, String pipelineName, boolean preserve) {
        this.outputDirectory = outputDirectory;
        this.pipelineName = pipelineName;
        this.rootDirectory = this.rootDirectory(preserve);
    }

    File rootDirectory(boolean preserve) {
        if (this.rootDirectory == null) {
            File file = new File(this.outputDirectory);
            if (!file.exists() || !file.isDirectory()) {
                throw new CompilationError("Output directory does not exist "
                        + Utilities.singleQuote(this.outputDirectory));
            }
            if (!preserve) {
                Utilities.deleteContents(file);
            }
            this.rootDirectory = file;
        }
        return this.rootDirectory;
    }

    @Override
    public void setOutputBuilder(IIndentStream stream) {
        throw new UnimplementedException();
    }

    public void write(CrateGenerator mainGenerator) throws IOException {
        File cargo = new File(this.rootDirectory, CrateGenerator.CARGO);
        PrintStream cargoStream = new PrintStream(Files.newOutputStream(cargo.toPath()));
        cargoStream.println("# Automatically generated by sql-to-dbsp");
        cargoStream.println("[workspace]");
        cargoStream.println("members = [");
        // It's enough to list the main crate.
        cargoStream.println("  " + Utilities.doubleQuote(mainGenerator.crateName));
        cargoStream.println("]");

        String deps = """
                [workspace.dependencies]
                paste = { version = "1.0.12" }
                derive_more = { version = "0.99.17", features = ["add", "not", "from"] }
                dbsp = { path = "$ROOT/crates/dbsp", features = ["backend-mode"] }
                dbsp_adapters = { path = "$ROOT/crates/adapters", default-features = false }
                feldera-types = { path = "$ROOT/crates/feldera-types" }
                feldera-sqllib = { path = "$ROOT/crates/sqllib" }
                serde = { version = "1.0", features = ["derive"] }
                compare = { version = "0.1.0" }
                size-of = { version = "0.1.5", package = "feldera-size-of" }
                serde_json = { version = "1.0.127", features = ["arbitrary_precision"] }
                rkyv = { version = "0.7.45", default-features = false, features = ["std", "size_64"] }
                tikv-jemallocator = { version = "0.6.0", features = ["profiling", "unprefixed_malloc_on_supported_platforms"] }""";

        final String relativePath = "../..";
        deps = deps.replace("$ROOT", relativePath);
        cargoStream.println(deps);
        cargoStream.close();
    }

    @Override
    public void write(DBSPCompiler compiler) throws IOException {
        StructuresUsed used = this.analyze(compiler);
        MultiCrates crates = new MultiCrates(this.rootDirectory, this.pipelineName, compiler, used);
        crates.addNodes(this.toWrite);
        crates.write();
        this.write(crates.main);
    }

    public String getGlobalsName() {
        // Keep in sync with MultiCrates.getGlobalsName
        return MultiCrates.FILE_PREFIX + this.pipelineName + "_globals";
    }
}
