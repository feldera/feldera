package org.dbsp.sqlCompiler.compiler.backend.rust.multi;

import org.dbsp.sqlCompiler.circuit.DBSPCircuit;
import org.dbsp.sqlCompiler.circuit.annotation.OperatorHash;
import org.dbsp.sqlCompiler.circuit.operator.DBSPNestedOperator;
import org.dbsp.sqlCompiler.circuit.operator.DBSPOperator;
import org.dbsp.sqlCompiler.circuit.operator.DBSPSimpleOperator;
import org.dbsp.sqlCompiler.circuit.operator.DBSPSourceBaseOperator;
import org.dbsp.sqlCompiler.circuit.operator.DBSPViewBaseOperator;
import org.dbsp.sqlCompiler.compiler.DBSPCompiler;
import org.dbsp.sqlCompiler.compiler.backend.rust.BaseRustCodeGenerator;
import org.dbsp.util.HashString;

import java.io.IOException;

/** Code generator for a circuit which instantiates each operator using a function call
 * generated by a {@link SingleOperatorWriter}. */
public final class CircuitWriter extends BaseRustCodeGenerator {
    private void processChild(DBSPOperator node) {
        DBSPOperator op = node.to(DBSPOperator.class);
        String name = op.getNodeName(false);
        String hash = op.getNodeName(true);
        HashString merkle = OperatorHash.getHash(node, true);
        if (!node.is(DBSPViewBaseOperator.class)) {
            this.builder().append("let ");
            if (node.is(DBSPSimpleOperator.class)) {
                this.builder().append(name);
            } else {
                this.builder().append("(");
                for (int i = 0; i < node.outputCount(); i++) {
                    String portName = node.getOutput(i).getName(false);
                    this.builder().append(portName)
                            .append(",");
                }
                this.builder().append(")");
            }
            this.builder().append(" = ");
        }
        this.builder().append("create_")
                .append(hash)
                .append("(&circuit, ");
        if (!node.is(DBSPNestedOperator.class)) {
            if (merkle != null) {
                this.builder().append("Some(\"")
                        .append(merkle.toString())
                        .append("\"), ");
            } else {
                this.builder().append("None, ");
            }
        }
        this.builder().append("&mut catalog, ");
        for (var input: op.inputs) {
            name = input.getName(false);
            this.builder().append("&")
                    .append(name)
                    .append(",");
        }
        this.builder().append(");").newline();
    }

    @Override
    public void write(DBSPCompiler compiler) throws IOException {
        this.builder().append(COMMON_PREAMBLE);
        this.builder().append(STANDARD_PREAMBLE);
        this.builder().append(ALLOC_PREAMBLE);
        for (String dep: this.dependencies)
            this.builder().append("use ")
                    .append(dep)
                    .append("::*;")
                    .newline();
        assert this.toWrite.size() == 1 : "Found " + this.toWrite.size() + " operators";
        DBSPCircuit circuit = this.toWrite.get(0).to(DBSPCircuit.class);
        this.builder().append("pub fn ")
                .append(circuit.getName());

        this.builder()
                .append("(cconf: CircuitConfig) -> Result<(DBSPHandle, Catalog), Error> {")
                .increase()
                .newline()
                .append("let (circuit, streams) = Runtime::init_circuit(cconf, |circuit| {")
                .increase();
        this.builder().append("let mut catalog = Catalog::new();").newline();

        // Process sources first
        for (DBSPOperator node : circuit.getAllOperators())
            if (node.is(DBSPSourceBaseOperator.class))
                this.processChild(node);

        for (DBSPOperator node : circuit.getAllOperators())
            if (!node.is(DBSPSourceBaseOperator.class))
                this.processChild(node);

        this.builder().append("Ok(catalog)");
        this.builder().newline()
                .decrease()
                .append("})?;")
                .newline();
        this.builder()
                .append("Ok((circuit, streams))")
                .newline()
                .decrease()
                .append("}")
                .newline();
    }
}
