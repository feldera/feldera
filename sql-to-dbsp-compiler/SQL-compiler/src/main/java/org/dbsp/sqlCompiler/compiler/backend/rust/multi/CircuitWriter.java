package org.dbsp.sqlCompiler.compiler.backend.rust.multi;

import org.dbsp.sqlCompiler.circuit.DBSPCircuit;
import org.dbsp.sqlCompiler.circuit.annotation.OperatorHash;
import org.dbsp.sqlCompiler.circuit.operator.DBSPNestedOperator;
import org.dbsp.sqlCompiler.circuit.operator.DBSPOperator;
import org.dbsp.sqlCompiler.circuit.operator.DBSPSimpleOperator;
import org.dbsp.sqlCompiler.circuit.operator.DBSPSourceBaseOperator;
import org.dbsp.sqlCompiler.circuit.operator.DBSPViewBaseOperator;
import org.dbsp.sqlCompiler.compiler.DBSPCompiler;
import org.dbsp.sqlCompiler.compiler.backend.rust.BaseRustCodeGenerator;
import org.dbsp.sqlCompiler.compiler.backend.rust.SourcePositionResource;
import org.dbsp.sqlCompiler.compiler.visitors.outer.CircuitVisitor;
import org.dbsp.sqlCompiler.compiler.visitors.outer.CollectSourcePositions;
import org.dbsp.util.HashString;
import org.dbsp.util.Linq;
import org.dbsp.util.Utilities;

import java.util.HashSet;
import java.util.List;
import java.util.Set;

/** Code generator for a circuit which instantiates each operator using a function call
 * generated by a {@link SingleOperatorWriter}. */
public final class CircuitWriter extends BaseRustCodeGenerator {
    public static final String SOURCE_MAP_VARIABLE_NAME = "sourceMap";

    private void processChild(DBSPOperator node) {
        DBSPOperator op = node.to(DBSPOperator.class);
        String name = op.getNodeName(false);
        String hash = op.getNodeName(true);
        HashString merkle = OperatorHash.getHash(node, true);
        if (!node.is(DBSPViewBaseOperator.class)) {
            this.builder().append("let ");
            if (node.is(DBSPSimpleOperator.class)) {
                this.builder().append(name);
            } else {
                this.builder().append("(");
                for (int i = 0; i < node.outputCount(); i++) {
                    if (node.hasOutput(i)) {
                        String portName = node.getOutput(i).getName(false);
                        this.builder().append(portName)
                                .append(",");
                    }
                }
                this.builder().append(")");
            }
            this.builder().append(" = ");
        }
        this.builder().append("create_")
                .append(hash)
                .append("(&circuit, ");
        if (!node.is(DBSPNestedOperator.class)) {
            if (merkle != null) {
                this.builder().append("Some(\"")
                        .append(merkle.toString())
                        .append("\"), ");
            } else {
                this.builder().append("None, ");
            }
        }
        this.builder().append("&")
                .append(SOURCE_MAP_VARIABLE_NAME)
                .append(", &mut catalog, ");
        for (var input: op.inputs) {
            name = input.getName(false);
            this.builder().append("&")
                    .append(name)
                    .append(",");
        }
        this.builder().append(");").newline();
    }

    @Override
    public void write(DBSPCompiler compiler) {
        this.builder().append(COMMON_PREAMBLE);
        this.builder().append(STANDARD_PREAMBLE);
        this.builder().append(ALLOC_PREAMBLE);
        Set<String> deps = new HashSet<>(this.dependencies);
        List<String> sorted = Linq.list(deps);
        sorted.sort(String::compareTo);
        for (String dep: sorted)
            this.builder().append("use ")
                    .append(dep)
                    .append("::*;")
                    .newline();
        Utilities.enforce(this.toWrite.size() == 1, "Found " + this.toWrite.size() + " operators");
        DBSPCircuit circuit = this.toWrite.get(0).to(DBSPCircuit.class);
        this.builder().append("pub fn ")
                .append(circuit.getName());

        this.builder()
                .append("(cconf: CircuitConfig) -> Result<(DBSPHandle, Catalog), Error> {")
                .increase()
                .newline()
                .append("let (circuit, streams) = dbsp_adapters::server::init_circuit(cconf, Box::new(|circuit| {")
                .increase();
        this.builder().append("let mut catalog = Catalog::new();").newline();

        SourcePositionResource sourcePositionResource = new SourcePositionResource();
        CircuitVisitor collector = new CollectSourcePositions(compiler, sourcePositionResource)
                .getCircuitVisitor(true);
        collector.apply(circuit);
        sourcePositionResource.generateInitializer(this.builder());
        SourcePositionResource.generateReference(this.builder(), CircuitWriter.SOURCE_MAP_VARIABLE_NAME);

        // Process sources first
        for (DBSPOperator node : circuit.getAllOperators())
            if (node.is(DBSPSourceBaseOperator.class))
                this.processChild(node);

        for (DBSPOperator node : circuit.getAllOperators())
            if (!node.is(DBSPSourceBaseOperator.class))
                this.processChild(node);

        this.builder().append("Ok(catalog)");
        this.builder().newline()
                .decrease()
                .append("}))?;")
                .newline();
        this.builder()
                .append("Ok((circuit, streams))")
                .newline()
                .decrease()
                .append("}")
                .newline();
    }
}
