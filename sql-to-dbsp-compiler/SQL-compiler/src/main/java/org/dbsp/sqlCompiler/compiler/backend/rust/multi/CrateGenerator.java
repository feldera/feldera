package org.dbsp.sqlCompiler.compiler.backend.rust.multi;

import org.dbsp.sqlCompiler.compiler.DBSPCompiler;
import org.dbsp.sqlCompiler.compiler.backend.rust.ICodeGenerator;
import org.dbsp.sqlCompiler.ir.IDBSPNode;
import org.dbsp.util.IndentStream;
import org.dbsp.util.IndentStreamBuilder;
import org.dbsp.util.Linq;
import org.dbsp.util.Utilities;

import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.nio.file.Files;
import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/** Generates a Rust crate in a specified directory.
 * Calls a ICodeGenerator to generate the Rust code. */
public final class CrateGenerator {
    public final File baseDirectory;
    public final String crateName;
    public final boolean enterprise;

    /** Cargo file name */
    public static final String CARGO = "Cargo.toml";
    /** Rust file name */
    public static final String LIB = "lib.rs";

    /** Crates that we depend on */
    private final Set<CrateGenerator> dependencies;
    /** Generates the actual Rust code */
    final ICodeGenerator codeGenerator;

    public CrateGenerator(File baseDirectory, String crateName, ICodeGenerator codeGenerator, boolean enterprise) {
        this.crateName = crateName;
        this.baseDirectory = baseDirectory;
        this.dependencies = new HashSet<>();
        this.codeGenerator = codeGenerator;
        this.enterprise = enterprise;
    }

    @Override
    public boolean equals(Object o) {
        if (o == null || getClass() != o.getClass()) return false;

        CrateGenerator that = (CrateGenerator) o;
        return this.baseDirectory.equals(that.baseDirectory) && this.crateName.equals(that.crateName);
    }

    @Override
    public int hashCode() {
        int result = this.baseDirectory.hashCode();
        result = 31 * result + this.crateName.hashCode();
        return result;
    }

    public void addDependency(CrateGenerator generator) {
        this.dependencies.add(generator);
        this.codeGenerator.addDependency(generator.crateName);
    }

    void generateCargo(PrintStream stream) {
        stream.println("# Automatically generated by sql-to-dbsp");
        stream.println("[package]");
        stream.print("name = \"");
        stream.print(this.crateName);
        stream.println("\"");

        String cargo = """
                version = "0.1.0"
                edition = "2021"
                publish = false
                
                [dev-dependencies]
                uuid = { version = "1.6.1" }

                [lib]
                path = "src/lib.rs"
                doctest = false
                
                [dependencies]
                paste = { workspace = true }
                derive_more = { workspace = true }
                dbsp = { workspace = true }
                dbsp_adapters = { workspace = true }
                feldera-types = { workspace = true }
                feldera-sqllib = { workspace = true }
                serde = { workspace = true }
                compare = { workspace = true }
                size-of = { workspace = true }
                rust_decimal = { workspace = true }
                rust_decimal_macros = { workspace = true }
                serde_json = { workspace = true }
                rkyv = { workspace = true }""";
        stream.println(cargo);
        if (this.enterprise)
            stream.println("dbsp-enterprise = { workspace = true }");
        String extraDep = """
                [target.'cfg(not(target_env = "msvc"))'.dependencies]
                tikv-jemallocator = { workspace = true }
                """;
        if (this.crateName.contains("main"))
            stream.println(extraDep);
        List<CrateGenerator> deps = Linq.list(this.dependencies);
        deps.sort(Comparator.comparing(a -> a.crateName));
        for (CrateGenerator dep: deps) {
            stream.println(dep.crateName + " = { path = " + Utilities.doubleQuote("../" + dep.crateName) + " }");
        }
    }

    public void add(IDBSPNode node) {
        this.codeGenerator.add(node);
    }

    public void write(DBSPCompiler compiler) throws IOException {
        if (!this.baseDirectory.exists())
            throw new RuntimeException(
                    "Directory " + Utilities.singleQuote(this.baseDirectory.getPath()) + " does not exist");
        if (!this.baseDirectory.isDirectory())
            throw new RuntimeException(
                    Utilities.singleQuote(this.baseDirectory.getPath()) + " is not a directory");
        File crateRoot = new File(this.baseDirectory, this.crateName);
        if (!crateRoot.exists()) {
            boolean success = crateRoot.mkdir();
            if (!success)
                throw new RuntimeException("Could not create directory " + Utilities.singleQuote(crateRoot.getPath()));
        }
        File cargo = new File(crateRoot, CARGO);
        PrintStream cargoStream = new PrintStream(Files.newOutputStream(cargo.toPath()));
        this.generateCargo(cargoStream);
        cargoStream.close();

        File src = new File(crateRoot, "src");
        if (!src.exists()) {
            boolean success = src.mkdir();
            if (!success)
                throw new RuntimeException("Could not create directory " + Utilities.singleQuote(src.getPath()));
        }
        File lib = new File(src, LIB);
        PrintStream rustStream = new PrintStream(Files.newOutputStream(lib.toPath()));
        this.codeGenerator.setOutputBuilder(new IndentStream(rustStream));
        this.codeGenerator.write(compiler);
        rustStream.close();
    }

    public String dump(DBSPCompiler compiler) throws IOException {
        IndentStreamBuilder builder = new IndentStreamBuilder();
        this.codeGenerator.setOutputBuilder(builder);
        this.codeGenerator.write(compiler);
        return builder.toString();
    }
}
