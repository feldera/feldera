package org.dbsp.sqlCompiler.ir.expression.literal;

import com.fasterxml.jackson.databind.JsonNode;
import org.dbsp.sqlCompiler.compiler.backend.JsonDecoder;
import org.dbsp.sqlCompiler.compiler.errors.InternalCompilerError;
import org.dbsp.sqlCompiler.compiler.frontend.calciteObject.CalciteObject;
import org.dbsp.sqlCompiler.ir.ISameValue;
import org.dbsp.sqlCompiler.ir.expression.DBSPExpression;
import org.dbsp.sqlCompiler.ir.type.DBSPTypeInterned;
import org.dbsp.util.IIndentStream;

/** The only literal we can represent of this type has value null.
 * Morever, users cannot write instances of this literal, it can only be generated by the compiler internally. */
public class DBSPInternedStringLiteral extends DBSPLiteral {
    public static DBSPInternedStringLiteral INSTANCE = new DBSPInternedStringLiteral();

    public DBSPInternedStringLiteral() {
        super(CalciteObject.EMPTY, DBSPTypeInterned.INSTANCE, true);
    }

    @Override
    public DBSPLiteral getWithNullable(boolean mayBeNull) {
        if (!mayBeNull)
            throw new InternalCompilerError("Non-null NULL value");
        return this;
    }

    @Override
    public String toSqlString() {
        throw new InternalCompilerError("Should not be called");
    }

    @Override
    public boolean sameValue(ISameValue expression) {
        return expression == DBSPInternedStringLiteral.INSTANCE;
    }

    @Override
    public DBSPExpression deepCopy() {
        return this;
    }

    @Override
    public IIndentStream toString(IIndentStream builder) {
        return builder.append("(")
                .append(this.type)
                .append(")null");
    }

    @SuppressWarnings("unused")
    public static DBSPInternedStringLiteral fromJson(JsonNode node, JsonDecoder decoder) {
        return INSTANCE;
    }
}
