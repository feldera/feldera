{
  "openapi": "3.0.3",
  "info": {
    "title": "Feldera API",
    "description": "\nWith Feldera, users create data pipelines out of SQL programs and data connectors. A SQL program comprises tables and views. Connectors feed data to input tables in a program or receive outputs computed by views.\n\nThis API allows users to create and manage data pipelines, and the programs\nand connectors that comprise these pipelines.\n\n# API concepts\n\n* *Program*.  A SQL program with a unique name and a unique ID\n  attached to it. A program contains tables and views. A program\n  needs to be compiled before it can be executed in a pipeline.\n\n* *Connector*. A data connector that can be used to feed input data to\nSQL tables or consume outputs from SQL views. Every connector\nhas a unique name and identifier. We currently support Kafka and Redpanda.\nWe also support directly ingesting and consuming data via HTTP;\nsee the `pipelines/{pipeline_id}/ingress` and `pipelines/{pipeline_id}/egress`\nendpoints.\n\n* *Service*. A service with a unique name and ID.\n  It represents a service (such as Kafka, etc.) that a connector can refer to in\n  its config. Services are declared separately to reduce duplication and to make it\n  easier to create connectors. A service has its own configuration, which\n  generally includes hostname, port, authentication, and any service parameters.\n\n* *Pipeline*.  A pipeline is a running instance of a program and\nsome attached connectors. A client can create multiple pipelines that make use of\nthe same program and connectors. Every pipeline has a unique name and identifier.\nDeploying a pipeline instantiates the pipeline with the then latest version of\nthe referenced program and connectors. This allows the API to accumulate edits\nto programs and connectors before use in a pipeline.\n\n# Concurrency\n\nAll programs have an associated *version*. This is done to prevent\nrace conditions due to multiple users accessing the same\nprogram concurrently.  An example is user 1 modifying the program,\nwhile user 2 is starting a pipeline for the same program. It would be confusing\nif the pipeline could end up running the old or the new version.\n\nA version is a monotonically increasing number, associated with each\nprogram and pipeline. Every request to compile the program or start a\npipeline must include the program id and version number. If the version number\nisn't equal to the current version in the database, this means that the\nlast version of the program observed by the client is outdated, so the\nrequest is rejected.",
    "license": {
      "name": "MIT OR Apache-2.0"
    },
    "version": "0.18.0"
  },
  "paths": {
    "/config/authentication": {
      "get": {
        "tags": [
          "Authentication"
        ],
        "summary": "Get authentication provider configuration",
        "operationId": "get_authentication_config",
        "responses": {
          "200": {
            "description": "The response body contains Authentication Provider configuration, or is empty if no auth is configured.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AuthProvider"
                }
              }
            }
          },
          "500": {
            "description": "Request failed.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        }
      }
    },
    "/v0/api_keys": {
      "get": {
        "tags": [
          "API keys"
        ],
        "summary": "List all API keys",
        "operationId": "list_api_keys",
        "parameters": [
          {
            "name": "name",
            "in": "query",
            "description": "API key name",
            "required": false,
            "schema": {
              "type": "string",
              "nullable": true
            }
          }
        ],
        "responses": {
          "200": {
            "description": "API keys retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ApiKeyDescr"
                  }
                }
              }
            }
          },
          "404": {
            "description": "Specified API key name does not exist.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "examples": {
                  "Unknown API key name": {
                    "value": {
                      "details": {
                        "name": "unknown_name"
                      },
                      "error_code": "UnknownName",
                      "message": "An entity with name unknown_name was not found"
                    }
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      },
      "post": {
        "tags": [
          "API keys"
        ],
        "summary": "Create an API key",
        "operationId": "create_api_key",
        "requestBody": {
          "description": "",
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/NewApiKeyRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "API key created successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NewApiKeyResponse"
                }
              }
            }
          },
          "409": {
            "description": "An api key with this name already exists.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": null,
                  "error_code": "DuplicateName",
                  "message": "An entity with this name already exists"
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      }
    },
    "/v0/api_keys/{api_key_name}": {
      "get": {
        "tags": [
          "API keys"
        ],
        "summary": "Get an API key description",
        "operationId": "get_api_key",
        "parameters": [
          {
            "name": "api_key_name",
            "in": "path",
            "description": "Unique API key name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "API key retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ApiKeyDescr"
                }
              }
            }
          },
          "404": {
            "description": "Specified API key name does not exist.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "examples": {
                  "Unknown API key name": {
                    "value": {
                      "details": {
                        "name": "unknown_name"
                      },
                      "error_code": "UnknownName",
                      "message": "An entity with name unknown_name was not found"
                    }
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      },
      "delete": {
        "tags": [
          "API keys"
        ],
        "summary": "Delete an API key",
        "operationId": "delete_api_key",
        "parameters": [
          {
            "name": "api_key_name",
            "in": "path",
            "description": "Unique API key name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "API key deleted successfully"
          },
          "404": {
            "description": "Specified API key name does not exist.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "examples": {
                  "Unknown API key name": {
                    "value": {
                      "details": {
                        "name": "unknown_name"
                      },
                      "error_code": "UnknownName",
                      "message": "An entity with name unknown_name was not found"
                    }
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      }
    },
    "/v0/config/demos": {
      "get": {
        "tags": [
          "Configuration"
        ],
        "summary": "Get the list of demo URLs.",
        "operationId": "get_demos",
        "responses": {
          "200": {
            "description": "URLs to JSON objects that describe a set of demos",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      }
    },
    "/v0/connectors": {
      "get": {
        "tags": [
          "Connectors"
        ],
        "summary": "Fetch connectors, optionally filtered by name or ID",
        "operationId": "list_connectors",
        "parameters": [
          {
            "name": "id",
            "in": "query",
            "description": "Unique connector identifier.",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uuid",
              "nullable": true
            }
          },
          {
            "name": "name",
            "in": "query",
            "description": "Unique connector name.",
            "required": false,
            "schema": {
              "type": "string",
              "nullable": true
            }
          }
        ],
        "responses": {
          "200": {
            "description": "List of connectors retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ConnectorDescr"
                  }
                }
              }
            }
          },
          "404": {
            "description": "Specified connector name or ID does not exist",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "examples": {
                  "Unknown connector ID": {
                    "value": {
                      "details": {
                        "connector_id": "d764b9e2-19f2-4572-ba20-8b42641b07c4"
                      },
                      "error_code": "UnknownConnector",
                      "message": "Unknown connector id 'd764b9e2-19f2-4572-ba20-8b42641b07c4'"
                    }
                  },
                  "Unknown connector name": {
                    "value": {
                      "details": {
                        "name": "unknown_name"
                      },
                      "error_code": "UnknownName",
                      "message": "An entity with name unknown_name was not found"
                    }
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      },
      "post": {
        "tags": [
          "Connectors"
        ],
        "summary": "Create a new connector.",
        "operationId": "new_connector",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/NewConnectorRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Connector successfully created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NewConnectorResponse"
                }
              }
            }
          },
          "409": {
            "description": "A connector with this name already exists in the database",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": null,
                  "error_code": "DuplicateName",
                  "message": "An entity with this name already exists"
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      }
    },
    "/v0/connectors/{connector_name}": {
      "get": {
        "tags": [
          "Connectors"
        ],
        "summary": "Fetch a connector by name.",
        "operationId": "get_connector",
        "parameters": [
          {
            "name": "connector_name",
            "in": "path",
            "description": "Unique connector name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Connector retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ConnectorDescr"
                }
              }
            }
          },
          "404": {
            "description": "Specified connector name does not exist",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": {
                    "name": "unknown_name"
                  },
                  "error_code": "UnknownName",
                  "message": "An entity with name unknown_name was not found"
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      },
      "put": {
        "tags": [
          "Connectors"
        ],
        "summary": "Create or replace a connector.",
        "operationId": "create_or_replace_connector",
        "parameters": [
          {
            "name": "connector_name",
            "in": "path",
            "description": "Unique connector name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateOrReplaceConnectorRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Connector updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateOrReplaceConnectorResponse"
                }
              }
            }
          },
          "201": {
            "description": "Connector created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateOrReplaceConnectorResponse"
                }
              }
            }
          },
          "409": {
            "description": "A connector with this name already exists in the database",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": null,
                  "error_code": "DuplicateName",
                  "message": "An entity with this name already exists"
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      },
      "delete": {
        "tags": [
          "Connectors"
        ],
        "summary": "Delete an existing connector.",
        "operationId": "delete_connector",
        "parameters": [
          {
            "name": "connector_name",
            "in": "path",
            "description": "Unique connector name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Connector successfully deleted"
          },
          "404": {
            "description": "Specified connector name does not exist",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": {
                    "name": "unknown_name"
                  },
                  "error_code": "UnknownName",
                  "message": "An entity with name unknown_name was not found"
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      },
      "patch": {
        "tags": [
          "Connectors"
        ],
        "summary": "Update the name, description and/or configuration of a connector.",
        "operationId": "update_connector",
        "parameters": [
          {
            "name": "connector_name",
            "in": "path",
            "description": "Unique connector name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateConnectorRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Connector successfully updated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateConnectorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Specified connector name does not exist",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": {
                    "name": "unknown_name"
                  },
                  "error_code": "UnknownName",
                  "message": "An entity with name unknown_name was not found"
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      }
    },
    "/v0/pipelines": {
      "get": {
        "tags": [
          "Pipelines"
        ],
        "summary": "Fetch pipelines, optionally filtered by name or ID.",
        "operationId": "list_pipelines",
        "parameters": [
          {
            "name": "id",
            "in": "query",
            "description": "Unique pipeline id.",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uuid",
              "nullable": true
            }
          },
          {
            "name": "name",
            "in": "query",
            "description": "Unique pipeline name.",
            "required": false,
            "schema": {
              "type": "string",
              "nullable": true
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Pipeline list retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Pipeline"
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      },
      "post": {
        "tags": [
          "Pipelines"
        ],
        "summary": "Create a new pipeline.",
        "operationId": "new_pipeline",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/NewPipelineRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Pipeline successfully created.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NewPipelineResponse"
                }
              }
            }
          },
          "404": {
            "description": "Specified program id or connector ids do not exist.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "examples": {
                  "Unknown connector": {
                    "description": "One or more connector ids do not exist.",
                    "value": {
                      "details": {
                        "connector_id": "d764b9e2-19f2-4572-ba20-8b42641b07c4"
                      },
                      "error_code": "UnknownConnector",
                      "message": "Unknown connector id 'd764b9e2-19f2-4572-ba20-8b42641b07c4'"
                    }
                  },
                  "Unknown program": {
                    "description": "Specified program id does not exist",
                    "value": {
                      "details": {
                        "program_id": "67e55044-10b1-426f-9247-bb680e5fe0c8"
                      },
                      "error_code": "UnknownProgram",
                      "message": "Unknown program id '67e55044-10b1-426f-9247-bb680e5fe0c8'"
                    }
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      }
    },
    "/v0/pipelines/{pipeline_name}": {
      "get": {
        "tags": [
          "Pipelines"
        ],
        "summary": "Fetch a pipeline by ID.",
        "operationId": "get_pipeline",
        "parameters": [
          {
            "name": "pipeline_name",
            "in": "path",
            "description": "Unique pipeline name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Pipeline descriptor retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Pipeline"
                },
                "example": {
                  "cpu_profiler": false,
                  "inputs": {
                    "Input-To-Table": {
                      "enable_output_buffer": false,
                      "format": {
                        "config": null,
                        "name": "csv"
                      },
                      "max_output_buffer_size_records": 18446744073709551615,
                      "max_output_buffer_time_millis": 18446744073709551615,
                      "max_queued_records": 1000000,
                      "stream": "my_input_table",
                      "transport": {
                        "config": {
                          "auto.offset.reset": "earliest",
                          "bootstrap.servers": "localhost:9092",
                          "fault_tolerance": null,
                          "group.instance.id": "group0",
                          "group_join_timeout_secs": 10,
                          "kafka_service": null,
                          "log_level": null,
                          "topics": [
                            "test_input1"
                          ]
                        },
                        "name": "kafka_input"
                      }
                    }
                  },
                  "max_buffering_delay_usecs": 0,
                  "min_batch_size_records": 0,
                  "min_storage_rows": null,
                  "name": "pipeline-67e55044-10b1-426f-9247-bb680e5fe0c8",
                  "outputs": {
                    "Output-To-View": {
                      "enable_output_buffer": false,
                      "format": {
                        "config": null,
                        "name": "csv"
                      },
                      "max_output_buffer_size_records": 18446744073709551615,
                      "max_output_buffer_time_millis": 18446744073709551615,
                      "max_queued_records": 1000000,
                      "stream": "my_output_view",
                      "transport": {
                        "config": {
                          "fault_tolerance": null,
                          "headers": [],
                          "initialization_timeout_secs": 60,
                          "kafka_service": null,
                          "log_level": null,
                          "max_inflight_messages": 1000,
                          "topic": "test_output1"
                        },
                        "name": "kafka_output"
                      }
                    }
                  },
                  "resources": {
                    "cpu_cores_max": null,
                    "cpu_cores_min": null,
                    "memory_mb_max": null,
                    "memory_mb_min": null,
                    "storage_class": null,
                    "storage_mb_max": null
                  },
                  "storage": false,
                  "storage_config": null,
                  "tcp_metrics_exporter": false,
                  "workers": 8
                }
              }
            }
          },
          "404": {
            "description": "Specified pipeline ID does not exist.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": {
                    "pipeline_id": "2e79afe1-ff4d-44d3-af5f-9397de7746c0"
                  },
                  "error_code": "UnknownPipeline",
                  "message": "Unknown pipeline id '2e79afe1-ff4d-44d3-af5f-9397de7746c0'"
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      },
      "put": {
        "tags": [
          "Pipelines"
        ],
        "summary": "Create or replace a pipeline.",
        "operationId": "create_or_replace_pipeline",
        "parameters": [
          {
            "name": "pipeline_name",
            "in": "path",
            "description": "Unique pipeline name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateOrReplacePipelineRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Pipeline updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateOrReplacePipelineResponse"
                }
              }
            }
          },
          "201": {
            "description": "Pipeline created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateOrReplacePipelineResponse"
                }
              }
            }
          },
          "409": {
            "description": "A pipeline with this name already exists in the database.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": null,
                  "error_code": "DuplicateName",
                  "message": "An entity with this name already exists"
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      },
      "delete": {
        "tags": [
          "Pipelines"
        ],
        "summary": "Delete a pipeline. The pipeline must be in the shutdown state.",
        "operationId": "pipeline_delete",
        "parameters": [
          {
            "name": "pipeline_name",
            "in": "path",
            "description": "Unique pipeline name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Pipeline successfully deleted."
          },
          "400": {
            "description": "Pipeline ID is invalid or pipeline is already running.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "examples": {
                  "Invalid Pipeline ID": {
                    "value": {
                      "details": {
                        "error": "invalid character: expected an optional prefix of `urn:uuid:` followed by [0-9a-fA-F-], found `n` at 1",
                        "value": "not_a_uuid"
                      },
                      "error_code": "InvalidUuidParam",
                      "message": "Invalid UUID string 'not_a_uuid': 'invalid character: expected an optional prefix of `urn:uuid:` followed by [0-9a-fA-F-], found `n` at 1'"
                    }
                  },
                  "Pipeline is running": {
                    "description": "Pipeline cannot be deleted while executing. Shutdown the pipeline first.",
                    "value": {
                      "details": {
                        "current_status": "Running",
                        "desired_status": "Running",
                        "error": "Cannot delete a running pipeline. Shutdown the pipeline first by invoking the '/shutdown' endpoint.",
                        "pipeline_id": "2e79afe1-ff4d-44d3-af5f-9397de7746c0",
                        "requested_status": null
                      },
                      "error_code": "IllegalPipelineStateTransition",
                      "message": "Action is not applicable in the current state of the pipeline: Cannot delete a running pipeline. Shutdown the pipeline first by invoking the '/shutdown' endpoint."
                    }
                  }
                }
              }
            }
          },
          "404": {
            "description": "Specified pipeline id does not exist.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": {
                    "pipeline_id": "2e79afe1-ff4d-44d3-af5f-9397de7746c0"
                  },
                  "error_code": "UnknownPipeline",
                  "message": "Unknown pipeline id '2e79afe1-ff4d-44d3-af5f-9397de7746c0'"
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      },
      "patch": {
        "tags": [
          "Pipelines"
        ],
        "summary": "Change a pipeline's name, description, code, configuration, or connectors.",
        "description": "On success, increments the pipeline's version by 1.",
        "operationId": "update_pipeline",
        "parameters": [
          {
            "name": "pipeline_name",
            "in": "path",
            "description": "Unique pipeline name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdatePipelineRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Pipeline successfully updated.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdatePipelineResponse"
                }
              }
            }
          },
          "404": {
            "description": "Specified pipeline or connector does not exist.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "examples": {
                  "Unknown connector name": {
                    "value": {
                      "details": {
                        "name": "unknown_name"
                      },
                      "error_code": "UnknownName",
                      "message": "An entity with name unknown_name was not found"
                    }
                  },
                  "Unknown pipeline name": {
                    "value": {
                      "details": {
                        "name": "unknown_name"
                      },
                      "error_code": "UnknownName",
                      "message": "An entity with name unknown_name was not found"
                    }
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      }
    },
    "/v0/pipelines/{pipeline_name}/config": {
      "get": {
        "tags": [
          "Pipelines"
        ],
        "summary": "Fetch a pipeline's configuration.",
        "description": "When defining a pipeline, clients have to provide an optional\n`RuntimeConfig` for the pipelines and references to existing\nconnectors to attach to the pipeline. This endpoint retrieves\nthe *expanded* definition of the pipeline's configuration,\nwhich comprises both the `RuntimeConfig` and the complete\ndefinitions of the attached connectors.",
        "operationId": "get_pipeline_config",
        "parameters": [
          {
            "name": "pipeline_name",
            "in": "path",
            "description": "Unique pipeline name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Expanded pipeline configuration retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PipelineConfig"
                }
              }
            }
          },
          "404": {
            "description": "Specified pipeline ID does not exist.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": {
                    "pipeline_id": "2e79afe1-ff4d-44d3-af5f-9397de7746c0"
                  },
                  "error_code": "UnknownPipeline",
                  "message": "Unknown pipeline id '2e79afe1-ff4d-44d3-af5f-9397de7746c0'"
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      }
    },
    "/v0/pipelines/{pipeline_name}/deployed": {
      "get": {
        "tags": [
          "Pipelines"
        ],
        "summary": "Return the currently deployed version of the pipeline, if any.",
        "operationId": "pipeline_deployed",
        "parameters": [
          {
            "name": "pipeline_name",
            "in": "path",
            "description": "Unique pipeline name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Last deployed version of the pipeline retrieved successfully (returns null if pipeline was never deployed yet).",
            "content": {
              "application/json": {
                "schema": {
                  "allOf": [
                    {
                      "$ref": "#/components/schemas/PipelineRevision"
                    }
                  ],
                  "nullable": true
                }
              }
            }
          },
          "404": {
            "description": "Specified `pipeline_id` does not exist.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": {
                    "pipeline_id": "2e79afe1-ff4d-44d3-af5f-9397de7746c0"
                  },
                  "error_code": "UnknownPipeline",
                  "message": "Unknown pipeline id '2e79afe1-ff4d-44d3-af5f-9397de7746c0'"
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      }
    },
    "/v0/pipelines/{pipeline_name}/dump_profile": {
      "get": {
        "tags": [
          "Pipelines"
        ],
        "summary": "Initiate profile dump.",
        "operationId": "dump_profile",
        "parameters": [
          {
            "name": "pipeline_name",
            "in": "path",
            "description": "Unique pipeline name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Profile dump initiated.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "Specified pipeline id is not a valid uuid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": {
                    "error": "invalid character: expected an optional prefix of `urn:uuid:` followed by [0-9a-fA-F-], found `n` at 1",
                    "value": "not_a_uuid"
                  },
                  "error_code": "InvalidUuidParam",
                  "message": "Invalid UUID string 'not_a_uuid': 'invalid character: expected an optional prefix of `urn:uuid:` followed by [0-9a-fA-F-], found `n` at 1'"
                }
              }
            }
          },
          "404": {
            "description": "Specified pipeline id does not exist.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": {
                    "pipeline_id": "2e79afe1-ff4d-44d3-af5f-9397de7746c0"
                  },
                  "error_code": "UnknownPipeline",
                  "message": "Unknown pipeline id '2e79afe1-ff4d-44d3-af5f-9397de7746c0'"
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      }
    },
    "/v0/pipelines/{pipeline_name}/egress/{table_name}": {
      "post": {
        "tags": [
          "HTTP input/output"
        ],
        "summary": "Subscribe to a stream of updates from a SQL view or table.",
        "description": "The pipeline responds with a continuous stream of changes to the specified\ntable or view, encoded using the format specified in the `?format=`\nparameter. Updates are split into `Chunk`s.\n\nThe pipeline continues sending updates until the client closes the\nconnection or the pipeline is shut down.\n\nThis API is a POST instead of a GET, because when performing neighborhood\nqueries (query='neighborhood'), the call expects a request body which\ncontains, among other things, a full row to execute a neighborhood search\naround. A row can be quite large and is not appropriate as a query\nparameter.",
        "operationId": "http_output",
        "parameters": [
          {
            "name": "pipeline_name",
            "in": "path",
            "description": "Unique pipeline name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "table_name",
            "in": "path",
            "description": "SQL table name. Unquoted SQL names have to be capitalized. Quoted SQL names have to exactly match the case from the SQL program.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "format",
            "in": "query",
            "description": "Output data format, e.g., 'csv' or 'json'.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "query",
            "in": "query",
            "description": "Query to execute on the table. Must be one of 'table', 'neighborhood', or 'quantiles'. The default value is 'table'",
            "required": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/OutputQuery"
                }
              ],
              "nullable": true
            }
          },
          {
            "name": "mode",
            "in": "query",
            "description": "Output mode. Must be one of 'watch' or 'snapshot'. The default value is 'watch'",
            "required": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/EgressMode"
                }
              ],
              "nullable": true
            }
          },
          {
            "name": "quantiles",
            "in": "query",
            "description": "For 'quantiles' queries: the number of quantiles to output. The default value is 100.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32",
              "nullable": true,
              "minimum": 0
            }
          },
          {
            "name": "array",
            "in": "query",
            "description": "Set to `true` to group updates in this stream into JSON arrays (used in conjunction with `format=json`). The default value is `false`",
            "required": false,
            "schema": {
              "type": "boolean",
              "nullable": true
            }
          },
          {
            "name": "backpressure",
            "in": "query",
            "description": "Apply backpressure on the pipeline when the HTTP client cannot receive data fast enough.\n        When this flag is set to false (the default), the HTTP connector drops data chunks if the client is not keeping up with its output.  This prevents a slow HTTP client from slowing down the entire pipeline.\n        When the flag is set to true, the connector waits for the client to receive each chunk and blocks the pipeline if the client cannot keep up.",
            "required": false,
            "schema": {
              "type": "boolean",
              "nullable": true
            }
          }
        ],
        "requestBody": {
          "description": "When the `query` parameter is set to 'neighborhood', the body of the request must contain a neighborhood specification.",
          "content": {
            "application/json": {
              "schema": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/NeighborhoodQuery"
                  }
                ],
                "nullable": true
              }
            }
          },
          "required": false
        },
        "responses": {
          "200": {
            "description": "Connection to the endpoint successfully established. The body of the response contains a stream of data chunks.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Chunk"
                }
              }
            }
          },
          "400": {
            "description": "Unknown data format specified in the '?format=' argument.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Specified table or view does not exist.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "410": {
            "description": "Pipeline is not currently running because it has been shutdown or not yet started.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": {
                    "pipeline_id": "2e79afe1-ff4d-44d3-af5f-9397de7746c0"
                  },
                  "error_code": "PipelineShutdown",
                  "message": "Pipeline 2e79afe1-ff4d-44d3-af5f-9397de7746c0 is not currently running."
                }
              }
            }
          },
          "500": {
            "description": "Request failed.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      }
    },
    "/v0/pipelines/{pipeline_name}/heap_profile": {
      "get": {
        "tags": [
          "Pipelines"
        ],
        "summary": "Retrieve heap profile of the pipeline.",
        "operationId": "heap_profile",
        "parameters": [
          {
            "name": "pipeline_name",
            "in": "path",
            "description": "Unique pipeline name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Pipeline's heap usage profile as a gzipped protobuf that can be inspected by the pprof tool.",
            "content": {
              "application/protobuf": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "400": {
            "description": "Specified pipeline id is not a valid uuid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": {
                    "error": "invalid character: expected an optional prefix of `urn:uuid:` followed by [0-9a-fA-F-], found `n` at 1",
                    "value": "not_a_uuid"
                  },
                  "error_code": "InvalidUuidParam",
                  "message": "Invalid UUID string 'not_a_uuid': 'invalid character: expected an optional prefix of `urn:uuid:` followed by [0-9a-fA-F-], found `n` at 1'"
                }
              }
            }
          },
          "404": {
            "description": "Specified pipeline id does not exist.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": {
                    "pipeline_id": "2e79afe1-ff4d-44d3-af5f-9397de7746c0"
                  },
                  "error_code": "UnknownPipeline",
                  "message": "Unknown pipeline id '2e79afe1-ff4d-44d3-af5f-9397de7746c0'"
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      }
    },
    "/v0/pipelines/{pipeline_name}/ingress/{table_name}": {
      "post": {
        "tags": [
          "HTTP input/output"
        ],
        "summary": "Push data to a SQL table.",
        "description": "The client sends data encoded using the format specified in the `?format=`\nparameter as a body of the request.  The contents of the data must match\nthe SQL table schema specified in `table_name`\n\nThe pipeline ingests data as it arrives without waiting for the end of\nthe request.  Successful HTTP response indicates that all data has been\ningested successfully.",
        "operationId": "http_input",
        "parameters": [
          {
            "name": "pipeline_name",
            "in": "path",
            "description": "Unique pipeline name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "table_name",
            "in": "path",
            "description": "SQL table name. Unquoted SQL names have to be capitalized. Quoted SQL names have to exactly match the case from the SQL program.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "force",
            "in": "query",
            "description": "When `true`, push data to the pipeline even if the pipeline is paused. The default value is `false`",
            "required": true,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "format",
            "in": "query",
            "description": "Input data format, e.g., 'csv' or 'json'.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "array",
            "in": "query",
            "description": "Set to `true` if updates in this stream are packaged into JSON arrays (used in conjunction with `format=json`). The default values is `false`.",
            "required": false,
            "schema": {
              "type": "boolean",
              "nullable": true
            }
          },
          {
            "name": "update_format",
            "in": "query",
            "description": "JSON data change event format (used in conjunction with `format=json`).  The default value is 'insert_delete'.",
            "required": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/JsonUpdateFormat"
                }
              ],
              "nullable": true
            }
          }
        ],
        "requestBody": {
          "description": "Contains the new input data in CSV.",
          "content": {
            "text/csv": {
              "schema": {
                "type": "string"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Data successfully delivered to the pipeline."
          },
          "400": {
            "description": "Error parsing input data.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          },
          "404": {
            "description": "Pipeline is not currently running because it has been shutdown or not yet started.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": {
                    "pipeline_id": "2e79afe1-ff4d-44d3-af5f-9397de7746c0"
                  },
                  "error_code": "PipelineShutdown",
                  "message": "Pipeline 2e79afe1-ff4d-44d3-af5f-9397de7746c0 is not currently running."
                }
              }
            }
          },
          "500": {
            "description": "Request failed.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      }
    },
    "/v0/pipelines/{pipeline_name}/stats": {
      "get": {
        "tags": [
          "Pipelines"
        ],
        "summary": "Retrieve pipeline metrics and performance counters.",
        "operationId": "pipeline_stats",
        "parameters": [
          {
            "name": "pipeline_name",
            "in": "path",
            "description": "Unique pipeline name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Pipeline metrics retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          },
          "400": {
            "description": "Specified pipeline id is not a valid uuid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": {
                    "error": "invalid character: expected an optional prefix of `urn:uuid:` followed by [0-9a-fA-F-], found `n` at 1",
                    "value": "not_a_uuid"
                  },
                  "error_code": "InvalidUuidParam",
                  "message": "Invalid UUID string 'not_a_uuid': 'invalid character: expected an optional prefix of `urn:uuid:` followed by [0-9a-fA-F-], found `n` at 1'"
                }
              }
            }
          },
          "404": {
            "description": "Specified pipeline id does not exist.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": {
                    "pipeline_id": "2e79afe1-ff4d-44d3-af5f-9397de7746c0"
                  },
                  "error_code": "UnknownPipeline",
                  "message": "Unknown pipeline id '2e79afe1-ff4d-44d3-af5f-9397de7746c0'"
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      }
    },
    "/v0/pipelines/{pipeline_name}/validate": {
      "get": {
        "tags": [
          "Pipelines"
        ],
        "summary": "Validate a pipeline.",
        "description": "Checks whether a pipeline is configured correctly. This includes\nchecking whether the pipeline references a valid compiled program,\nwhether the connectors reference valid tables/views in the program,\nand more.",
        "operationId": "pipeline_validate",
        "parameters": [
          {
            "name": "pipeline_name",
            "in": "path",
            "description": "Unique pipeline name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Validate a Pipeline config.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "400": {
            "description": "Invalid pipeline.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "examples": {
                  "Invalid Pipeline ID": {
                    "description": "Specified pipeline id is not a valid uuid.",
                    "value": {
                      "details": {
                        "error": "invalid character: expected an optional prefix of `urn:uuid:` followed by [0-9a-fA-F-], found `n` at 1",
                        "value": "not_a_uuid"
                      },
                      "error_code": "InvalidUuidParam",
                      "message": "Invalid UUID string 'not_a_uuid': 'invalid character: expected an optional prefix of `urn:uuid:` followed by [0-9a-fA-F-], found `n` at 1'"
                    }
                  },
                  "Invalid table or view reference": {
                    "description": "Connectors reference a view that doesn't exist.",
                    "value": {
                      "details": {
                        "missing": [
                          [
                            "ac_name",
                            "my_view"
                          ]
                        ]
                      },
                      "error_code": "ViewsNotInSchema",
                      "message": "Pipeline configuration specifies invalid connector->view pairs 'ac_name -> my_view': The view(s) don't exist in the program"
                    }
                  },
                  "Invalid table reference": {
                    "description": "Connectors reference a table that doesn't exist.",
                    "value": {
                      "details": {
                        "missing": [
                          [
                            "ac_name",
                            "my_table"
                          ]
                        ]
                      },
                      "error_code": "TablesNotInSchema",
                      "message": "Pipeline configuration specifies invalid connector->table pairs 'ac_name -> my_table': The table(s) don't exist in the program"
                    }
                  },
                  "Program has compilation errors": {
                    "description": "The program associated with the pipeline raised compilation error.",
                    "value": {
                      "details": null,
                      "error_code": "ProgramFailedToCompile",
                      "message": "The program attached to the pipeline did not compile successfully"
                    }
                  },
                  "Program not compiled": {
                    "description": "The program associated with this pipeline has not been compiled.",
                    "value": {
                      "details": null,
                      "error_code": "ProgramNotCompiled",
                      "message": "The program attached to the pipeline hasn't been compiled yet."
                    }
                  },
                  "Program not set": {
                    "description": "Pipeline does not have a program set.",
                    "value": {
                      "details": null,
                      "error_code": "ProgramNotSet",
                      "message": "The pipeline does not have a program attached"
                    }
                  }
                }
              }
            }
          },
          "404": {
            "description": "Specified pipeline id does not exist.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": {
                    "pipeline_id": "2e79afe1-ff4d-44d3-af5f-9397de7746c0"
                  },
                  "error_code": "UnknownPipeline",
                  "message": "Unknown pipeline id '2e79afe1-ff4d-44d3-af5f-9397de7746c0'"
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      }
    },
    "/v0/pipelines/{pipeline_name}/{action}": {
      "post": {
        "tags": [
          "Pipelines"
        ],
        "summary": "Change the desired state of the pipeline.",
        "description": "This endpoint allows the user to control the execution of the pipeline,\nby changing its desired state attribute (see the discussion of the desired\nstate model in the [`PipelineStatus`] documentation).\n\nThe endpoint returns immediately after validating the request and forwarding\nit to the pipeline. The requested status change completes asynchronously.\nOn success, the pipeline enters the requested desired state.  On error, the\npipeline transitions to the `Failed` state. The user\ncan monitor the current status of the pipeline by polling the `GET\n/pipeline` endpoint.\n\nThe following values of the `action` argument are accepted by this endpoint:\n\n- 'start': Start processing data.\n- 'pause': Pause the pipeline.\n- 'shutdown': Terminate the execution of the pipeline.",
        "operationId": "pipeline_action",
        "parameters": [
          {
            "name": "pipeline_name",
            "in": "path",
            "description": "Unique pipeline name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "action",
            "in": "path",
            "description": "Pipeline action [start, pause, shutdown]",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "202": {
            "description": "Request accepted."
          },
          "400": {
            "description": "Pipeline desired state is not valid.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "examples": {
                  "Action cannot be applied": {
                    "description": "Action is not applicable in the current state of the pipeline.",
                    "value": {
                      "details": {
                        "current_status": "ShuttingDown",
                        "desired_status": "Shutdown",
                        "error": "Cannot restart the pipeline while it is shutting down. Wait for the shutdown to complete before starting a new instance of the pipeline.",
                        "pipeline_id": "2e79afe1-ff4d-44d3-af5f-9397de7746c0",
                        "requested_status": "Running"
                      },
                      "error_code": "IllegalPipelineStateTransition",
                      "message": "Action is not applicable in the current state of the pipeline: Cannot restart the pipeline while it is shutting down. Wait for the shutdown to complete before starting a new instance of the pipeline."
                    }
                  },
                  "Invalid Pipeline ID": {
                    "description": "Specified pipeline id is not a valid uuid.",
                    "value": {
                      "details": {
                        "error": "invalid character: expected an optional prefix of `urn:uuid:` followed by [0-9a-fA-F-], found `n` at 1",
                        "value": "not_a_uuid"
                      },
                      "error_code": "InvalidUuidParam",
                      "message": "Invalid UUID string 'not_a_uuid': 'invalid character: expected an optional prefix of `urn:uuid:` followed by [0-9a-fA-F-], found `n` at 1'"
                    }
                  },
                  "Invalid action": {
                    "description": "Invalid action specified",
                    "value": {
                      "details": {
                        "action": "my_action"
                      },
                      "error_code": "InvalidPipelineAction",
                      "message": "Invalid pipeline action 'my_action'; valid actions are: 'deploy', 'start', 'pause', or 'shutdown'"
                    }
                  },
                  "Invalid table or view reference": {
                    "description": "Connectors reference a view that doesn't exist.",
                    "value": {
                      "details": {
                        "missing": [
                          [
                            "ac_name",
                            "my_view"
                          ]
                        ]
                      },
                      "error_code": "ViewsNotInSchema",
                      "message": "Pipeline configuration specifies invalid connector->view pairs 'ac_name -> my_view': The view(s) don't exist in the program"
                    }
                  },
                  "Invalid table reference": {
                    "description": "Connectors reference a table that doesn't exist.",
                    "value": {
                      "details": {
                        "missing": [
                          [
                            "ac_name",
                            "my_table"
                          ]
                        ]
                      },
                      "error_code": "TablesNotInSchema",
                      "message": "Pipeline configuration specifies invalid connector->table pairs 'ac_name -> my_table': The table(s) don't exist in the program"
                    }
                  },
                  "Invalidtable or view reference": {
                    "description": "Connectors reference a view that doesn't exist.",
                    "value": {
                      "details": {
                        "missing": [
                          [
                            "ac_name",
                            "my_view"
                          ]
                        ]
                      },
                      "error_code": "ViewsNotInSchema",
                      "message": "Pipeline configuration specifies invalid connector->view pairs 'ac_name -> my_view': The view(s) don't exist in the program"
                    }
                  },
                  "Program has compilation errors": {
                    "description": "The program associated with the pipeline raised compilation error.",
                    "value": {
                      "details": null,
                      "error_code": "ProgramFailedToCompile",
                      "message": "The program attached to the pipeline did not compile successfully"
                    }
                  },
                  "Program not compiled": {
                    "description": "The program associated with this pipeline has not been compiled.",
                    "value": {
                      "details": null,
                      "error_code": "ProgramNotCompiled",
                      "message": "The program attached to the pipeline hasn't been compiled yet."
                    }
                  },
                  "Program not set": {
                    "description": "Pipeline does not have a program set.",
                    "value": {
                      "details": null,
                      "error_code": "ProgramNotSet",
                      "message": "The pipeline does not have a program attached"
                    }
                  }
                }
              }
            }
          },
          "404": {
            "description": "Specified pipeline id does not exist.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": {
                    "pipeline_id": "2e79afe1-ff4d-44d3-af5f-9397de7746c0"
                  },
                  "error_code": "UnknownPipeline",
                  "message": "Unknown pipeline id '2e79afe1-ff4d-44d3-af5f-9397de7746c0'"
                }
              }
            }
          },
          "500": {
            "description": "Timeout waiting for the pipeline to initialize.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": {
                    "pipeline_id": "2e79afe1-ff4d-44d3-af5f-9397de7746c0",
                    "timeout": {
                      "nanos": 0,
                      "secs": 10
                    }
                  },
                  "error_code": "PipelineInitializationTimeout",
                  "message": "Waiting for pipeline 2e79afe1-ff4d-44d3-af5f-9397de7746c0 initialization timed out after 10s"
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      }
    },
    "/v0/programs": {
      "get": {
        "tags": [
          "Programs"
        ],
        "summary": "Fetch programs, optionally filtered by name or ID.",
        "operationId": "get_programs",
        "parameters": [
          {
            "name": "id",
            "in": "query",
            "description": "Unique program identifier.",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uuid",
              "nullable": true
            }
          },
          {
            "name": "name",
            "in": "query",
            "description": "Unique program name.",
            "required": false,
            "schema": {
              "type": "string",
              "nullable": true
            }
          },
          {
            "name": "with_code",
            "in": "query",
            "description": "Option to include the SQL program code or not\nin the Program objects returned by the query.\nIf false (default), the returned program object\nwill not include the code.",
            "required": false,
            "schema": {
              "type": "boolean",
              "nullable": true
            }
          }
        ],
        "responses": {
          "200": {
            "description": "List of programs retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ProgramDescr"
                  }
                }
              }
            }
          },
          "404": {
            "description": "Specified program name or ID does not exist",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "examples": {
                  "Unknown program ID": {
                    "value": {
                      "details": {
                        "program_id": "67e55044-10b1-426f-9247-bb680e5fe0c8"
                      },
                      "error_code": "UnknownProgram",
                      "message": "Unknown program id '67e55044-10b1-426f-9247-bb680e5fe0c8'"
                    }
                  },
                  "Unknown program name": {
                    "value": {
                      "details": {
                        "name": "unknown_name"
                      },
                      "error_code": "UnknownName",
                      "message": "An entity with name unknown_name was not found"
                    }
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      },
      "post": {
        "tags": [
          "Programs"
        ],
        "summary": "Create a new program.",
        "operationId": "new_program",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/NewProgramRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Program created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NewProgramResponse"
                }
              }
            }
          },
          "409": {
            "description": "A program with this name already exists in the database",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": null,
                  "error_code": "DuplicateName",
                  "message": "An entity with this name already exists"
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      }
    },
    "/v0/programs/{program_name}": {
      "get": {
        "tags": [
          "Programs"
        ],
        "summary": "Fetch a program by name.",
        "operationId": "get_program",
        "parameters": [
          {
            "name": "program_name",
            "in": "path",
            "description": "Unique program name",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "with_code",
            "in": "query",
            "description": "Option to include the SQL program code or not\nin the Program objects returned by the query.\nIf false (default), the returned program object\nwill not include the code.",
            "required": false,
            "schema": {
              "type": "boolean",
              "nullable": true
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Program retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ProgramDescr"
                }
              }
            }
          },
          "404": {
            "description": "Specified program name does not exist",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": {
                    "name": "unknown_name"
                  },
                  "error_code": "UnknownName",
                  "message": "An entity with name unknown_name was not found"
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      },
      "put": {
        "tags": [
          "Programs"
        ],
        "summary": "Create or replace a program.",
        "operationId": "create_or_replace_program",
        "parameters": [
          {
            "name": "program_name",
            "in": "path",
            "description": "Unique program name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreateOrReplaceProgramRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Program updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateOrReplaceProgramResponse"
                }
              }
            }
          },
          "201": {
            "description": "Program created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateOrReplaceProgramResponse"
                }
              }
            }
          },
          "409": {
            "description": "A program with this name already exists in the database",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": null,
                  "error_code": "DuplicateName",
                  "message": "An entity with this name already exists"
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      },
      "delete": {
        "tags": [
          "Programs"
        ],
        "summary": "Delete a program.",
        "description": "Deletion fails if there is at least one pipeline associated with the\nprogram.",
        "operationId": "delete_program",
        "parameters": [
          {
            "name": "program_name",
            "in": "path",
            "description": "Unique program name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Program successfully deleted"
          },
          "400": {
            "description": "Specified program is referenced by a pipeline",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": {
                    "program_name": "unknown_name"
                  },
                  "error_code": "ProgramInUseByPipeline",
                  "message": "Program named 'unknown_name' is in use by a pipeline"
                }
              }
            }
          },
          "404": {
            "description": "Specified program name does not exist",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": {
                    "name": "unknown_name"
                  },
                  "error_code": "UnknownName",
                  "message": "An entity with name unknown_name was not found"
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      },
      "patch": {
        "tags": [
          "Programs"
        ],
        "summary": "Change one or more of a program's code, description or name.",
        "description": "If a program's code changes, any ongoing compilation gets cancelled,\nthe program status is reset to `None`, and the program version\nis incremented by 1.\n\nChanging only the program's name or description does not affect its\nversion or the compilation process.",
        "operationId": "update_program",
        "parameters": [
          {
            "name": "program_name",
            "in": "path",
            "description": "Unique program name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateProgramRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Program updated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateProgramResponse"
                }
              }
            }
          },
          "404": {
            "description": "Specified program name does not exist",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": {
                    "name": "unknown_name"
                  },
                  "error_code": "UnknownName",
                  "message": "An entity with name unknown_name was not found"
                }
              }
            }
          },
          "409": {
            "description": "A program with this name already exists in the database",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": null,
                  "error_code": "DuplicateName",
                  "message": "An entity with this name already exists"
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      }
    },
    "/v0/programs/{program_name}/compile": {
      "post": {
        "tags": [
          "Programs"
        ],
        "summary": "Deprecated. Mark a program for compilation.",
        "description": "The client can track a program's compilation status by polling the\n`/program/{program_name}` or `/programs` endpoints, and\nthen checking the `status` field of the program object.",
        "operationId": "compile_program",
        "parameters": [
          {
            "name": "program_name",
            "in": "path",
            "description": "Unique program name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CompileProgramRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "202": {
            "description": "Compilation request submitted"
          },
          "404": {
            "description": "Specified program name does not exist",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": {
                    "name": "unknown_name"
                  },
                  "error_code": "UnknownName",
                  "message": "An entity with name unknown_name was not found"
                }
              }
            }
          },
          "409": {
            "description": "Program version specified in the request doesn't match the latest program version in the database",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": {
                    "latest_version": 5
                  },
                  "error_code": "OutdatedProgramVersion",
                  "message": "Outdated program version. Latest version: '5'"
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      }
    },
    "/v0/services": {
      "get": {
        "tags": [
          "Services"
        ],
        "summary": "Fetch services, optionally filtered by name, ID or configuration type.",
        "operationId": "list_services",
        "parameters": [
          {
            "name": "id",
            "in": "query",
            "description": "If provided, will filter based on exact match of the service identifier.",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uuid",
              "nullable": true
            }
          },
          {
            "name": "name",
            "in": "query",
            "description": "If provided, will filter based on exact match of the service name.",
            "required": false,
            "schema": {
              "type": "string",
              "nullable": true
            }
          },
          {
            "name": "config_type",
            "in": "query",
            "description": "If provided, will filter based on exact match of the configuration type.",
            "required": false,
            "schema": {
              "type": "string",
              "nullable": true
            }
          }
        ],
        "responses": {
          "200": {
            "description": "List of services retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ServiceDescr"
                  }
                }
              }
            }
          },
          "404": {
            "description": "Specified service name or ID does not exist",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "examples": {
                  "Unknown service ID": {
                    "value": {
                      "details": {
                        "service_id": "12345678-9123-4567-8912-345678912345"
                      },
                      "error_code": "UnknownService",
                      "message": "Unknown service id '12345678-9123-4567-8912-345678912345'"
                    }
                  },
                  "Unknown service name": {
                    "value": {
                      "details": {
                        "name": "unknown_name"
                      },
                      "error_code": "UnknownName",
                      "message": "An entity with name unknown_name was not found"
                    }
                  }
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      },
      "post": {
        "tags": [
          "Services"
        ],
        "summary": "Create a new service.",
        "operationId": "new_service",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/NewServiceRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Service successfully created",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/NewServiceResponse"
                }
              }
            }
          },
          "409": {
            "description": "A service with this name already exists in the database",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": null,
                  "error_code": "DuplicateName",
                  "message": "An entity with this name already exists"
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      }
    },
    "/v0/services/{service_name}": {
      "get": {
        "tags": [
          "Services"
        ],
        "summary": "Fetch a service by name.",
        "operationId": "get_service",
        "parameters": [
          {
            "name": "service_name",
            "in": "path",
            "description": "Unique service name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Service retrieved successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServiceDescr"
                }
              }
            }
          },
          "404": {
            "description": "Specified service name does not exist",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": {
                    "name": "unknown_name"
                  },
                  "error_code": "UnknownName",
                  "message": "An entity with name unknown_name was not found"
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      },
      "delete": {
        "tags": [
          "Services"
        ],
        "summary": "Delete an existing service.",
        "operationId": "delete_service",
        "parameters": [
          {
            "name": "service_name",
            "in": "path",
            "description": "Unique service name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Service successfully deleted"
          },
          "404": {
            "description": "Specified service name does not exist",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": {
                    "name": "unknown_name"
                  },
                  "error_code": "UnknownName",
                  "message": "An entity with name unknown_name was not found"
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      },
      "patch": {
        "tags": [
          "Services"
        ],
        "summary": "Update the name, description and/or configuration of a service.",
        "operationId": "update_service",
        "parameters": [
          {
            "name": "service_name",
            "in": "path",
            "description": "Unique service name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/UpdateServiceRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "Service successfully updated",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdateServiceResponse"
                }
              }
            }
          },
          "404": {
            "description": "Specified service name does not exist",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": {
                    "name": "unknown_name"
                  },
                  "error_code": "UnknownName",
                  "message": "An entity with name unknown_name was not found"
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      }
    },
    "/v0/services/{service_name}/probes": {
      "get": {
        "tags": [
          "Services"
        ],
        "summary": "Fetch a list of probes for a service, optionally filtered by id.",
        "operationId": "list_service_probes",
        "parameters": [
          {
            "name": "id",
            "in": "query",
            "description": "If provided, will filter based on exact match of the service probe\nidentifier.",
            "required": false,
            "schema": {
              "type": "string",
              "format": "uuid",
              "nullable": true
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "If provided, will limit the amount of probes to the N most recent.",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int32",
              "nullable": true,
              "minimum": 0
            }
          },
          {
            "name": "type",
            "in": "query",
            "description": "If provided, will only have probes of that particular type.",
            "required": false,
            "schema": {
              "allOf": [
                {
                  "$ref": "#/components/schemas/ServiceProbeType"
                }
              ],
              "nullable": true
            }
          },
          {
            "name": "service_name",
            "in": "path",
            "description": "Unique service name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "Service probes retrieved successfully.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ServiceProbeDescr"
                  }
                }
              }
            }
          },
          "404": {
            "description": "Specified service name does not exist",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": {
                    "name": "unknown_name"
                  },
                  "error_code": "UnknownName",
                  "message": "An entity with name unknown_name was not found"
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      },
      "post": {
        "tags": [
          "Services"
        ],
        "summary": "Create a service probe.",
        "operationId": "new_service_probe",
        "parameters": [
          {
            "name": "service_name",
            "in": "path",
            "description": "Unique service name",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ServiceProbeRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "201": {
            "description": "Service probe created successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateServiceProbeResponse"
                }
              }
            }
          },
          "404": {
            "description": "Specified service name does not exist",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ErrorResponse"
                },
                "example": {
                  "details": {
                    "name": "unknown_name"
                  },
                  "error_code": "UnknownName",
                  "message": "An entity with name unknown_name was not found"
                }
              }
            }
          }
        },
        "security": [
          {
            "JSON web token (JWT) or API key": []
          }
        ]
      }
    }
  },
  "components": {
    "schemas": {
      "ApiKeyDescr": {
        "type": "object",
        "description": "ApiKey descriptor.",
        "required": [
          "id",
          "name",
          "scopes"
        ],
        "properties": {
          "id": {
            "$ref": "#/components/schemas/ApiKeyId"
          },
          "name": {
            "type": "string"
          },
          "scopes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ApiPermission"
            }
          }
        }
      },
      "ApiKeyId": {
        "type": "string",
        "format": "uuid",
        "description": "ApiKey ID."
      },
      "ApiPermission": {
        "type": "string",
        "description": "Permission types for invoking pipeline manager APIs",
        "enum": [
          "Read",
          "Write"
        ]
      },
      "AttachedConnector": {
        "type": "object",
        "description": "Format to add attached connectors during a config update.",
        "required": [
          "name",
          "is_input",
          "connector_name",
          "relation_name"
        ],
        "properties": {
          "connector_name": {
            "type": "string",
            "description": "The name of the connector to attach."
          },
          "is_input": {
            "type": "boolean",
            "description": "True for input connectors, false for output connectors."
          },
          "name": {
            "type": "string",
            "description": "A unique identifier for this attachement."
          },
          "relation_name": {
            "type": "string",
            "description": "The table or view this connector is attached to. Unquoted\ntable/view names in the SQL program need to be capitalized\nhere. Quoted table/view names have to exactly match the\ncasing from the SQL program."
          }
        }
      },
      "AttachedConnectorId": {
        "type": "string",
        "format": "uuid",
        "description": "Unique attached connector id."
      },
      "AuthProvider": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "AwsCognito"
            ],
            "properties": {
              "AwsCognito": {
                "$ref": "#/components/schemas/ProviderAwsCognito"
              }
            }
          },
          {
            "type": "object",
            "required": [
              "GoogleIdentity"
            ],
            "properties": {
              "GoogleIdentity": {
                "$ref": "#/components/schemas/ProviderGoogleIdentity"
              }
            }
          }
        ]
      },
      "AwsCredentials": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "type"
            ],
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "NoSignRequest"
                ]
              }
            }
          },
          {
            "type": "object",
            "description": "Authenticate using a long-lived AWS access key and secret",
            "required": [
              "aws_access_key_id",
              "aws_secret_access_key",
              "type"
            ],
            "properties": {
              "aws_access_key_id": {
                "type": "string"
              },
              "aws_secret_access_key": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "AccessKey"
                ]
              }
            }
          }
        ],
        "description": "Configuration to authenticate against AWS",
        "discriminator": {
          "propertyName": "type"
        }
      },
      "Chunk": {
        "type": "object",
        "description": "A set of updates to a SQL table or view.\n\nThe `sequence_number` field stores the offset of the chunk relative to the\nstart of the stream and can be used to implement reliable delivery.\nThe payload is stored in the `bin_data`, `text_data`, or `json_data` field\ndepending on the data format used.",
        "required": [
          "sequence_number"
        ],
        "properties": {
          "bin_data": {
            "type": "string",
            "format": "binary",
            "description": "Base64 encoded binary payload, e.g., bincode.",
            "nullable": true
          },
          "json_data": {
            "type": "object",
            "description": "JSON payload.",
            "nullable": true
          },
          "sequence_number": {
            "type": "integer",
            "format": "int64",
            "minimum": 0
          },
          "text_data": {
            "type": "string",
            "description": "Text payload, e.g., CSV.",
            "nullable": true
          }
        }
      },
      "ColumnType": {
        "type": "object",
        "description": "A SQL column type description.\n\nMatches the Calcite JSON format.",
        "required": [
          "nullable"
        ],
        "properties": {
          "component": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ColumnType"
              }
            ],
            "nullable": true
          },
          "fields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Field"
            },
            "description": "The fields of the type (if available).\n\nFor example this would specify the fields of a `CREATE TYPE` construct.\n\n```sql\nCREATE TYPE person_typ AS (\nfirstname       VARCHAR(30),\nlastname        VARCHAR(30),\naddress         ADDRESS_TYP\n);\n```\n\nWould lead to the following `fields` value:\n\n```sql\n[\nColumnType { name: \"firstname, ... },\nColumnType { name: \"lastname\", ... },\nColumnType { name: \"address\", fields: [ ... ] }\n]\n```",
            "nullable": true
          },
          "nullable": {
            "type": "boolean",
            "description": "Does the type accept NULL values?"
          },
          "precision": {
            "type": "integer",
            "format": "int64",
            "description": "Precision of the type.\n\n# Examples\n- `VARCHAR` sets precision to `-1`.\n- `VARCHAR(255)` sets precision to `255`.\n- `BIGINT`, `DATE`, `FLOAT`, `DOUBLE`, `GEOMETRY`, etc. sets precision\nto None\n- `TIME`, `TIMESTAMP` set precision to `0`.",
            "nullable": true
          },
          "scale": {
            "type": "integer",
            "format": "int64",
            "description": "The scale of the type.\n\n# Example\n- `DECIMAL(1,2)` sets scale to `2`.",
            "nullable": true
          },
          "type": {
            "$ref": "#/components/schemas/SqlType"
          }
        }
      },
      "CompilationProfile": {
        "type": "string",
        "description": "Enumeration of possible compilation profiles that can be passed to the Rust compiler\nas an argument via `cargo build --profile <>`. A compilation profile affects among\nother things the compilation speed (how long till the program is ready to be run)\nand runtime speed (the performance while running).",
        "enum": [
          "dev",
          "unoptimized",
          "optimized"
        ]
      },
      "CompileProgramRequest": {
        "type": "object",
        "description": "Request to queue a program for compilation.",
        "required": [
          "version"
        ],
        "properties": {
          "version": {
            "$ref": "#/components/schemas/Version"
          }
        }
      },
      "ConnectorConfig": {
        "allOf": [
          {
            "$ref": "#/components/schemas/OutputBufferConfig"
          },
          {
            "type": "object",
            "required": [
              "transport"
            ],
            "properties": {
              "format": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/FormatConfig"
                  }
                ],
                "nullable": true
              },
              "max_queued_records": {
                "type": "integer",
                "format": "int64",
                "description": "Backpressure threshold.\n\nMaximal number of records queued by the endpoint before the endpoint\nis paused by the backpressure mechanism.\n\nFor input endpoints, this setting bounds the number of records that have\nbeen received from the input transport but haven't yet been consumed by\nthe circuit since the circuit, since the circuit is still busy processing\nprevious inputs.\n\nFor output endpoints, this setting bounds the number of records that have\nbeen produced by the circuit but not yet sent via the output transport endpoint\nnor stored in the output buffer (see `enable_output_buffer`).\n\nNote that this is not a hard bound: there can be a small delay between\nthe backpressure mechanism is triggered and the endpoint is paused, during\nwhich more data may be queued.\n\nThe default is 1 million.",
                "minimum": 0
              },
              "transport": {
                "$ref": "#/components/schemas/TransportConfig"
              }
            }
          }
        ],
        "description": "A data connector's configuration"
      },
      "ConnectorDescr": {
        "type": "object",
        "description": "Connector descriptor.",
        "required": [
          "connector_id",
          "name",
          "description",
          "config"
        ],
        "properties": {
          "config": {
            "$ref": "#/components/schemas/ConnectorConfig"
          },
          "connector_id": {
            "$ref": "#/components/schemas/ConnectorId"
          },
          "description": {
            "type": "string"
          },
          "name": {
            "type": "string"
          }
        }
      },
      "ConnectorId": {
        "type": "string",
        "format": "uuid",
        "description": "Unique connector id."
      },
      "ConsumeStrategy": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "type"
            ],
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "Fragment"
                ]
              }
            }
          },
          {
            "type": "object",
            "required": [
              "type"
            ],
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "Object"
                ]
              }
            }
          }
        ],
        "description": "Strategy to feed a fetched object into an InputConsumer."
      },
      "CreateOrReplaceConnectorRequest": {
        "type": "object",
        "description": "Request to create or replace a connector.",
        "required": [
          "description",
          "config"
        ],
        "properties": {
          "config": {
            "$ref": "#/components/schemas/ConnectorConfig"
          },
          "description": {
            "type": "string",
            "description": "New connector description."
          }
        }
      },
      "CreateOrReplaceConnectorResponse": {
        "type": "object",
        "description": "Response to a create or replace connector request.",
        "required": [
          "connector_id"
        ],
        "properties": {
          "connector_id": {
            "$ref": "#/components/schemas/ConnectorId"
          }
        }
      },
      "CreateOrReplacePipelineRequest": {
        "type": "object",
        "description": "Request to create or replace an existing pipeline.",
        "required": [
          "description",
          "config"
        ],
        "properties": {
          "config": {
            "$ref": "#/components/schemas/RuntimeConfig"
          },
          "connectors": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AttachedConnector"
            },
            "description": "Attached connectors.",
            "nullable": true
          },
          "description": {
            "type": "string",
            "description": "Pipeline description."
          },
          "program_name": {
            "type": "string",
            "description": "Name of the program to create a pipeline for.",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "CreateOrReplacePipelineResponse": {
        "type": "object",
        "description": "Response to a pipeline create or replace request.",
        "required": [
          "pipeline_id",
          "version"
        ],
        "properties": {
          "pipeline_id": {
            "$ref": "#/components/schemas/PipelineId"
          },
          "version": {
            "$ref": "#/components/schemas/Version"
          }
        }
      },
      "CreateOrReplaceProgramRequest": {
        "type": "object",
        "description": "Request to create or replace a program.",
        "required": [
          "description",
          "code"
        ],
        "properties": {
          "code": {
            "type": "string",
            "description": "SQL code of the program.",
            "example": "CREATE TABLE example(name VARCHAR);"
          },
          "config": {
            "$ref": "#/components/schemas/ProgramConfig"
          },
          "description": {
            "type": "string",
            "description": "Program description.",
            "example": "Example description"
          }
        }
      },
      "CreateOrReplaceProgramResponse": {
        "type": "object",
        "description": "Response to a create or replace program request.",
        "required": [
          "program_id",
          "version"
        ],
        "properties": {
          "program_id": {
            "$ref": "#/components/schemas/ProgramId"
          },
          "version": {
            "$ref": "#/components/schemas/Version"
          }
        }
      },
      "CreateOrReplaceServiceRequest": {
        "type": "object",
        "description": "Request to create or replace a service.",
        "required": [
          "description",
          "config"
        ],
        "properties": {
          "config": {
            "$ref": "#/components/schemas/ServiceConfig"
          },
          "description": {
            "type": "string",
            "description": "Service description."
          }
        }
      },
      "CreateOrReplaceServiceResponse": {
        "type": "object",
        "description": "Response to a create or replace service request.",
        "required": [
          "service_id"
        ],
        "properties": {
          "service_id": {
            "$ref": "#/components/schemas/ServiceId"
          }
        }
      },
      "CreateServiceProbeResponse": {
        "type": "object",
        "description": "Response to a create service probe request.",
        "required": [
          "service_probe_id"
        ],
        "properties": {
          "service_probe_id": {
            "$ref": "#/components/schemas/ServiceProbeId"
          }
        }
      },
      "CsvEncoderConfig": {
        "type": "object",
        "properties": {
          "buffer_size_records": {
            "type": "integer",
            "minimum": 0
          }
        }
      },
      "CsvParserConfig": {
        "type": "object"
      },
      "DeltaTableIngestMode": {
        "type": "string",
        "description": "Delta table read mode.\n\nThree options are available:\n\n* `snapshot` - read a snapshot of the table and stop.\n\n* `follow` - continuously ingest changes to the table, starting from a specified version\nor timestamp.\n\n* `snapshot_and_follow` - read a snapshot of the table before switching to continuous ingestion\nmode.",
        "enum": [
          "snapshot",
          "follow",
          "snapshot_and_follow"
        ]
      },
      "DeltaTableReaderConfig": {
        "type": "object",
        "description": "Delta table output connector configuration.",
        "required": [
          "uri",
          "mode"
        ],
        "properties": {
          "datetime": {
            "type": "string",
            "description": "Optional timestamp for the snapshot in the ISO-8601/RFC-3339 format, e.g.,\n\"2024-12-09T16:09:53+00:00.\n\nWhen this option is set, the connector finds and opens the version of the table as of the\nspecified point in time.  In `snapshot` and `snapshot_and_follow` modes, it retrieves the\nsnapshot of this version of the table (based on the server time recorded in the transaction\nlog, not the event time encoded in the data).  In `follow` and `snapshot_and_follow` modes, it\nfollows transaction log records **after** this version.\n\nNote: at most one of `version` and `datetime` options can be specified.\nWhen neither of the two options is specified, the latest committed version of the table\nis used.",
            "nullable": true
          },
          "mode": {
            "$ref": "#/components/schemas/DeltaTableIngestMode"
          },
          "snapshot_filter": {
            "type": "string",
            "description": "Optional row filter.\n\nThis option is only valid when `mode` is set to `snapshot` or `snapshot_and_follow`.\n\nWhen specified, only rows that satisfy the filter condition are included in the\nsnapshot.  The condition must be a valid SQL Boolean expression that can be used in\nthe `where` clause of the `select * from snapshot where ...` query.\n\nThis option can be used to specify the range of event times to include in the snapshot,\ne.g.: `ts BETWEEN '2005-01-01 00:00:00' AND '2010-12-31 23:59:59'`.",
            "nullable": true
          },
          "timestamp_column": {
            "type": "string",
            "description": "Table column that serves as an event timestamp.\n\n\nWhen this option is specified, and `mode` is one of `snapshot` or `snapshot_and_follow`,\nthe snapshot of the table is ingested in the timestamp order.  This setting is required\nfor tables declared with the\n[`LATENESS`](https://www.feldera.com/docs/sql/streaming#lateness-expressions) attribute\nin Feldera SQL. It impacts the performance of the connector, since data must be sorted\nbefore pushing it to the pipeline; therefore it is not recommended to use this\nsettings for tables without `LATENESS`.",
            "nullable": true
          },
          "uri": {
            "type": "string",
            "description": "Table URI.\n\nExample: \"s3://feldera-fraud-detection-data/demographics_train\""
          },
          "version": {
            "type": "integer",
            "format": "int64",
            "description": "Optional table version.\n\nWhen this option is set, the connector finds and opens the specified version of the table.\nIn `snapshot` and `snapshot_and_follow` modes, it retrieves the snapshot of this version of\nthe table.  In `follow` and `snapshot_and_follow` modes, it follows transaction log records\n**after** this version.\n\nNote: at most one of `version` and `datetime` options can be specified.\nWhen neither of the two options is specified, the latest committed version of the table\nis used.",
            "nullable": true
          }
        },
        "additionalProperties": {
          "type": "string",
          "description": "Storage options for configuring backend object store.\n\nFor specific options available for different storage backends, see:\n* [Azure options](https://docs.rs/object_store/latest/object_store/azure/enum.AzureConfigKey.html)\n* [Amazon S3 options](https://docs.rs/object_store/latest/object_store/aws/enum.AmazonS3ConfigKey.html)\n* [Google Cloud Storage options](https://docs.rs/object_store/latest/object_store/gcp/enum.GoogleConfigKey.html)"
        }
      },
      "DeltaTableWriteMode": {
        "type": "string",
        "description": "Delta table write mode.\n\nDetermines how the Delta table connector handles an existing table at the target location.",
        "enum": [
          "append",
          "truncate",
          "error_if_exists"
        ]
      },
      "DeltaTableWriterConfig": {
        "type": "object",
        "description": "Delta table output connector configuration.",
        "required": [
          "uri"
        ],
        "properties": {
          "mode": {
            "$ref": "#/components/schemas/DeltaTableWriteMode"
          },
          "uri": {
            "type": "string",
            "description": "Table URI."
          }
        },
        "additionalProperties": {
          "type": "string",
          "description": "Storage options for configuring backend object store.\n\nFor specific options available for different storage backends, see:\n* [Azure options](https://docs.rs/object_store/latest/object_store/azure/enum.AzureConfigKey.html)\n* [Amazon S3 options](https://docs.rs/object_store/latest/object_store/aws/enum.AmazonS3ConfigKey.html)\n* [Google Cloud Storage options](https://docs.rs/object_store/latest/object_store/gcp/enum.GoogleConfigKey.html)"
        }
      },
      "EgressMode": {
        "type": "string",
        "enum": [
          "watch",
          "snapshot"
        ]
      },
      "ErrorResponse": {
        "type": "object",
        "description": "Information returned by REST API endpoints on error.",
        "required": [
          "message",
          "error_code",
          "details"
        ],
        "properties": {
          "details": {
            "type": "object",
            "description": "Detailed error metadata.\nThe contents of this field is determined by `error_code`."
          },
          "error_code": {
            "type": "string",
            "description": "Error code is a string that specifies this error type.",
            "example": "UnknownInputFormat"
          },
          "message": {
            "type": "string",
            "description": "Human-readable error message.",
            "example": "Unknown input format 'xml'."
          }
        }
      },
      "Field": {
        "type": "object",
        "description": "A SQL field.\n\nMatches the SQL compiler JSON format.",
        "required": [
          "name",
          "columntype"
        ],
        "properties": {
          "case_sensitive": {
            "type": "boolean"
          },
          "columntype": {
            "$ref": "#/components/schemas/ColumnType"
          },
          "name": {
            "type": "string"
          }
        }
      },
      "FileInputConfig": {
        "type": "object",
        "description": "Configuration for reading data from a file with `FileInputTransport`",
        "required": [
          "path"
        ],
        "properties": {
          "buffer_size_bytes": {
            "type": "integer",
            "description": "Read buffer size.\n\nDefault: when this parameter is not specified, a platform-specific\ndefault is used.",
            "nullable": true,
            "minimum": 0
          },
          "follow": {
            "type": "boolean",
            "description": "Enable file following.\n\nWhen `false`, the endpoint outputs an `InputConsumer::eoi`\nmessage and stops upon reaching the end of file.  When `true`, the\nendpoint will keep watching the file and outputting any new content\nappended to it."
          },
          "path": {
            "type": "string",
            "description": "File path."
          }
        }
      },
      "FileOutputConfig": {
        "type": "object",
        "description": "Configuration for writing data to a file with `FileOutputTransport`.",
        "required": [
          "path"
        ],
        "properties": {
          "path": {
            "type": "string",
            "description": "File path."
          }
        }
      },
      "FormatConfig": {
        "type": "object",
        "description": "Data format specification used to parse raw data received from the\nendpoint or to encode data sent to the endpoint.",
        "required": [
          "name"
        ],
        "properties": {
          "config": {
            "type": "object",
            "description": "Format-specific parser or encoder configuration."
          },
          "name": {
            "type": "string",
            "description": "Format name, e.g., \"csv\", \"json\", \"bincode\", etc."
          }
        }
      },
      "InputEndpointConfig": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ConnectorConfig"
          },
          {
            "type": "object",
            "required": [
              "stream"
            ],
            "properties": {
              "stream": {
                "type": "string",
                "description": "The name of the input stream of the circuit that this endpoint is\nconnected to."
              }
            }
          }
        ],
        "description": "Describes an input connector configuration"
      },
      "IntervalUnit": {
        "type": "string",
        "description": "The specified units for SQL Interval types.\n\n`INTERVAL 1 DAY`, `INTERVAL 1 DAY TO HOUR`, `INTERVAL 1 DAY TO MINUTE`,\nwould yield `Day`, `DayToHour`, `DayToMinute`, as the `IntervalUnit` respectively.",
        "enum": [
          "DAY",
          "DAYTOHOUR",
          "DAYTOMINUTE",
          "DAYTOSECOND",
          "HOUR",
          "HOURTOMINUTE",
          "HOURTOSECOND",
          "MINUTE",
          "MINUTETOSECOND",
          "MONTH",
          "SECOND",
          "YEAR",
          "YEARTOMONTH"
        ]
      },
      "JsonEncoderConfig": {
        "type": "object",
        "properties": {
          "array": {
            "type": "boolean"
          },
          "buffer_size_records": {
            "type": "integer",
            "minimum": 0
          },
          "json_flavor": {
            "allOf": [
              {
                "$ref": "#/components/schemas/JsonFlavor"
              }
            ],
            "nullable": true
          },
          "update_format": {
            "$ref": "#/components/schemas/JsonUpdateFormat"
          }
        }
      },
      "JsonFlavor": {
        "type": "string",
        "description": "Specifies JSON encoding used of table records.",
        "enum": [
          "default",
          "debezium_mysql",
          "snowflake",
          "kafka_connect_json_converter",
          "pandas"
        ]
      },
      "JsonParserConfig": {
        "type": "object",
        "description": "JSON parser configuration.\n\nDescribes the shape of an input JSON stream.\n\n# Examples\n\nA configuration with `update_format=\"raw\"` and `array=false`\nis used to parse a stream of JSON objects without any envelope\nthat get inserted in the input table.\n\n```json\n{\"b\": false, \"i\": 100, \"s\": \"foo\"}\n{\"b\": true, \"i\": 5, \"s\": \"bar\"}\n```\n\nA configuration with `update_format=\"insert_delete\"` and\n`array=false` is used to parse a stream of JSON data change events\nin the insert/delete format:\n\n```json\n{\"delete\": {\"b\": false, \"i\": 15, \"s\": \"\"}}\n{\"insert\": {\"b\": false, \"i\": 100, \"s\": \"foo\"}}\n```\n\nA configuration with `update_format=\"insert_delete\"` and\n`array=true` is used to parse a stream of JSON arrays\nwhere each array contains multiple data change events in\nthe insert/delete format.\n\n```json\n[{\"insert\": {\"b\": true, \"i\": 0}}, {\"delete\": {\"b\": false, \"i\": 100, \"s\": \"foo\"}}]\n```",
        "properties": {
          "array": {
            "type": "boolean",
            "description": "Set to `true` if updates in this stream are packaged into JSON arrays.\n\n# Example\n\n```json\n[{\"b\": true, \"i\": 0},{\"b\": false, \"i\": 100, \"s\": \"foo\"}]\n```"
          },
          "json_flavor": {
            "$ref": "#/components/schemas/JsonFlavor"
          },
          "update_format": {
            "$ref": "#/components/schemas/JsonUpdateFormat"
          }
        }
      },
      "JsonUpdateFormat": {
        "type": "string",
        "description": "Supported JSON data change event formats.\n\nEach element in a JSON-formatted input stream specifies\nan update to one or more records in an input table.  We support\nseveral different ways to represent such updates.",
        "enum": [
          "insert_delete",
          "weighted",
          "debezium",
          "snowflake",
          "raw"
        ]
      },
      "KafkaHeader": {
        "type": "object",
        "description": "Kafka message header.",
        "required": [
          "key"
        ],
        "properties": {
          "key": {
            "type": "string"
          },
          "value": {
            "allOf": [
              {
                "$ref": "#/components/schemas/KafkaHeaderValue"
              }
            ],
            "nullable": true
          }
        }
      },
      "KafkaHeaderValue": {
        "type": "string",
        "format": "binary",
        "description": "Kafka header value encoded as a UTF-8 string or a byte array."
      },
      "KafkaInputConfig": {
        "type": "object",
        "description": "Configuration for reading data from Kafka topics with `InputTransport`.",
        "required": [
          "topics"
        ],
        "properties": {
          "fault_tolerance": {
            "allOf": [
              {
                "$ref": "#/components/schemas/KafkaInputFtConfig"
              }
            ],
            "nullable": true
          },
          "group_join_timeout_secs": {
            "type": "integer",
            "format": "int32",
            "description": "Maximum timeout in seconds to wait for the endpoint to join the Kafka\nconsumer group during initialization.",
            "minimum": 0
          },
          "kafka_service": {
            "type": "string",
            "description": "If specified, this service is used to provide defaults for the Kafka options.",
            "nullable": true
          },
          "log_level": {
            "allOf": [
              {
                "$ref": "#/components/schemas/KafkaLogLevel"
              }
            ],
            "nullable": true
          },
          "topics": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of topics to subscribe to."
          }
        },
        "additionalProperties": {
          "type": "string",
          "description": "Options passed directly to `rdkafka`.\n\n[`librdkafka` options](https://github.com/edenhill/librdkafka/blob/master/CONFIGURATION.md)\nused to configure the Kafka consumer.  Not all options are valid with\nthis Kafka adapter:\n\n* \"enable.auto.commit\", if present, must be set to \"false\",\n* \"enable.auto.offset.store\", if present, must be set to \"false\""
        }
      },
      "KafkaInputFtConfig": {
        "type": "object",
        "description": "Fault tolerance configuration for Kafka input connector.",
        "properties": {
          "consumer_options": {
            "type": "object",
            "description": "Options passed to `rdkafka` for consumers only, as documented at\n[`librdkafka`\noptions](https://github.com/edenhill/librdkafka/blob/master/CONFIGURATION.md).\n\nThese options override `kafka_options` for consumers, and may be empty.",
            "additionalProperties": {
              "type": "string"
            }
          },
          "create_missing_index": {
            "type": "boolean",
            "description": "If this is true or unset, then the connector will create missing index\ntopics as needed.  If this is false, then a missing index topic is a\nfatal error.",
            "nullable": true
          },
          "index_suffix": {
            "type": "string",
            "description": "Suffix to append to each data topic name, to give the name of a topic\nthat the connector uses for recording the division of the corresponding\ndata topic into steps.  Defaults to `_input-index`.\n\nAn index topic must have the same number of partitions as its\ncorresponding data topic.\n\nIf two or more fault-tolerant Kafka endpoints read from overlapping sets\nof topics, they must specify different `index_suffix` values.",
            "nullable": true
          },
          "max_step_bytes": {
            "type": "integer",
            "format": "int64",
            "description": "Maximum number of bytes in a step.  Any individual message bigger than\nthis will be given a step of its own.",
            "nullable": true,
            "minimum": 0
          },
          "max_step_messages": {
            "type": "integer",
            "format": "int64",
            "description": "Maximum number of messages in a step.",
            "nullable": true,
            "minimum": 0
          },
          "producer_options": {
            "type": "object",
            "description": "Options passed to `rdkafka` for producers only, as documented at\n[`librdkafka`\noptions](https://github.com/edenhill/librdkafka/blob/master/CONFIGURATION.md).\n\nThese options override `kafka_options` for producers, and may be empty.",
            "additionalProperties": {
              "type": "string"
            }
          }
        }
      },
      "KafkaLogLevel": {
        "type": "string",
        "description": "Kafka logging levels.",
        "enum": [
          "emerg",
          "alert",
          "critical",
          "error",
          "warning",
          "notice",
          "info",
          "debug"
        ]
      },
      "KafkaOutputConfig": {
        "type": "object",
        "description": "Configuration for writing data to a Kafka topic with `OutputTransport`.",
        "required": [
          "topic"
        ],
        "properties": {
          "fault_tolerance": {
            "allOf": [
              {
                "$ref": "#/components/schemas/KafkaOutputFtConfig"
              }
            ],
            "nullable": true
          },
          "headers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/KafkaHeader"
            },
            "description": "Kafka headers to be added to each message produced by this connector."
          },
          "initialization_timeout_secs": {
            "type": "integer",
            "format": "int32",
            "description": "Maximum timeout in seconds to wait for the endpoint to connect to\na Kafka broker.\n\nDefaults to 60.",
            "minimum": 0
          },
          "kafka_service": {
            "type": "string",
            "description": "If specified, this service is used to provide defaults for the Kafka options.",
            "nullable": true
          },
          "log_level": {
            "allOf": [
              {
                "$ref": "#/components/schemas/KafkaLogLevel"
              }
            ],
            "nullable": true
          },
          "max_inflight_messages": {
            "type": "integer",
            "format": "int32",
            "description": "Maximum number of unacknowledged messages buffered by the Kafka\nproducer.\n\nKafka producer buffers outgoing messages until it receives an\nacknowledgement from the broker.  This configuration parameter\nbounds the number of unacknowledged messages.  When the number of\nunacknowledged messages reaches this limit, sending of a new message\nblocks until additional acknowledgements arrive from the broker.\n\nDefaults to 1000.",
            "minimum": 0
          },
          "topic": {
            "type": "string",
            "description": "Topic to write to."
          }
        },
        "additionalProperties": {
          "type": "string",
          "description": "Options passed directly to `rdkafka`.\n\nSee [`librdkafka` options](https://github.com/edenhill/librdkafka/blob/master/CONFIGURATION.md)\nused to configure the Kafka producer."
        }
      },
      "KafkaOutputFtConfig": {
        "type": "object",
        "description": "Fault tolerance configuration for Kafka output connector.",
        "properties": {
          "consumer_options": {
            "type": "object",
            "description": "Options passed to `rdkafka` for consumers only, as documented at\n[`librdkafka`\noptions](https://github.com/edenhill/librdkafka/blob/master/CONFIGURATION.md).\n\nThese options override `kafka_options` for consumers, and may be empty.",
            "additionalProperties": {
              "type": "string"
            }
          },
          "producer_options": {
            "type": "object",
            "description": "Options passed to `rdkafka` for producers only, as documented at\n[`librdkafka`\noptions](https://github.com/edenhill/librdkafka/blob/master/CONFIGURATION.md).\n\nThese options override `kafka_options` for producers, and may be empty.",
            "additionalProperties": {
              "type": "string"
            }
          }
        }
      },
      "KafkaService": {
        "type": "object",
        "description": "Configuration for accessing a Kafka service.",
        "required": [
          "bootstrap_servers",
          "options"
        ],
        "properties": {
          "bootstrap_servers": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "List of bootstrap servers, each formatted as hostname:port (e.g.,\n\"example.com:1234\"). It will be used to set the `bootstrap.servers`\nKafka option."
          },
          "options": {
            "type": "object",
            "description": "Additional Kafka options.\n\nShould not contain the bootstrap.servers key\nas it is passed explicitly via its field.\n\nThese options will likely encompass things\nlike SSL and authentication configuration.",
            "additionalProperties": {
              "type": "string"
            }
          }
        }
      },
      "NeighborhoodQuery": {
        "type": "object",
        "description": "A request to output a specific neighborhood of a table or view.\nThe neighborhood is defined in terms of its central point (`anchor`)\nand the number of rows preceding and following the anchor to output.",
        "required": [
          "before",
          "after"
        ],
        "properties": {
          "after": {
            "type": "integer",
            "format": "int32",
            "minimum": 0
          },
          "anchor": {
            "type": "object",
            "nullable": true
          },
          "before": {
            "type": "integer",
            "format": "int32",
            "minimum": 0
          }
        }
      },
      "NewApiKeyRequest": {
        "type": "object",
        "description": "Request to create a new API key.",
        "required": [
          "name"
        ],
        "properties": {
          "name": {
            "type": "string",
            "description": "Key name.",
            "example": "my-api-key"
          }
        }
      },
      "NewApiKeyResponse": {
        "type": "object",
        "description": "Response to a successful API key creation.",
        "required": [
          "api_key_id",
          "name",
          "api_key"
        ],
        "properties": {
          "api_key": {
            "type": "string",
            "description": "Generated API key. There is no way to\nretrieve this key again from the\npipeline-manager, so store it securely.",
            "example": "apikey:v5y5QNtlPNVMwkmNjKwFU8bbIu5lMge3yHbyddxAOdXlEo84SEoNn32DUhQaf1KLeI9aOOfnJjhQ1pYzMrU4wQXON6pm6BS7Zgzj46U2b8pwz1280vYBEtx41hiDBRP"
          },
          "api_key_id": {
            "$ref": "#/components/schemas/ApiKeyId"
          },
          "name": {
            "type": "string",
            "description": "API key name",
            "example": "my-api-key"
          }
        }
      },
      "NewConnectorRequest": {
        "type": "object",
        "description": "Request to create a new connector.",
        "required": [
          "name",
          "description",
          "config"
        ],
        "properties": {
          "config": {
            "$ref": "#/components/schemas/ConnectorConfig"
          },
          "description": {
            "type": "string",
            "description": "Connector description."
          },
          "name": {
            "type": "string",
            "description": "Connector name."
          }
        }
      },
      "NewConnectorResponse": {
        "type": "object",
        "description": "Response to a connector creation request.",
        "required": [
          "connector_id"
        ],
        "properties": {
          "connector_id": {
            "$ref": "#/components/schemas/ConnectorId"
          }
        }
      },
      "NewPipelineRequest": {
        "type": "object",
        "description": "Request to create a new pipeline.",
        "required": [
          "name",
          "description",
          "config"
        ],
        "properties": {
          "config": {
            "$ref": "#/components/schemas/RuntimeConfig"
          },
          "connectors": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AttachedConnector"
            },
            "description": "Attached connectors.",
            "nullable": true
          },
          "description": {
            "type": "string",
            "description": "Pipeline description."
          },
          "name": {
            "type": "string",
            "description": "Unique pipeline name."
          },
          "program_name": {
            "type": "string",
            "description": "Name of the program to create a pipeline for.",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "NewPipelineResponse": {
        "type": "object",
        "description": "Response to a pipeline creation request.",
        "required": [
          "pipeline_id",
          "version"
        ],
        "properties": {
          "pipeline_id": {
            "$ref": "#/components/schemas/PipelineId"
          },
          "version": {
            "$ref": "#/components/schemas/Version"
          }
        }
      },
      "NewProgramRequest": {
        "type": "object",
        "description": "Request to create a new program.",
        "required": [
          "name",
          "description",
          "code"
        ],
        "properties": {
          "code": {
            "type": "string",
            "description": "SQL code of the program.",
            "example": "CREATE TABLE example(name VARCHAR);"
          },
          "config": {
            "$ref": "#/components/schemas/ProgramConfig"
          },
          "description": {
            "type": "string",
            "description": "Program description.",
            "example": "Example description"
          },
          "name": {
            "type": "string",
            "description": "Program name.",
            "example": "example-program"
          }
        }
      },
      "NewProgramResponse": {
        "type": "object",
        "description": "Response to a new program request.",
        "required": [
          "program_id",
          "version"
        ],
        "properties": {
          "program_id": {
            "$ref": "#/components/schemas/ProgramId"
          },
          "version": {
            "$ref": "#/components/schemas/Version"
          }
        }
      },
      "NewServiceRequest": {
        "type": "object",
        "description": "Request to create a new service.",
        "required": [
          "name",
          "description",
          "config"
        ],
        "properties": {
          "config": {
            "$ref": "#/components/schemas/ServiceConfig"
          },
          "description": {
            "type": "string",
            "description": "Service description."
          },
          "name": {
            "type": "string",
            "description": "Service name."
          }
        }
      },
      "NewServiceResponse": {
        "type": "object",
        "description": "Response to a service creation request.",
        "required": [
          "service_id"
        ],
        "properties": {
          "service_id": {
            "$ref": "#/components/schemas/ServiceId"
          }
        }
      },
      "OutputBufferConfig": {
        "type": "object",
        "properties": {
          "enable_output_buffer": {
            "type": "boolean",
            "description": "Enable output buffering.\n\nThe output buffering mechanism allows decoupling the rate at which the pipeline\npushes changes to the output transport from the rate of input changes.\n\nBy default, output updates produced by the pipeline are pushed directly to\nthe output transport. Some destinations may prefer to receive updates in fewer\nbigger batches. For instance, when writing Parquet files, producing\none bigger file every few minutes is usually better than creating\nsmall files every few milliseconds.\n\nTo achieve such input/output decoupling, users can enable output buffering by\nsetting the `enable_output_buffer` flag to `true`.  When buffering is enabled, output\nupdates produced by the pipeline are consolidated in an internal buffer and are\npushed to the output transport when one of several conditions is satisfied:\n\n* data has been accumulated in the buffer for more than `max_output_buffer_time_millis`\nmilliseconds.\n* buffer size exceeds `max_output_buffer_size_records` records.\n\nThis flag is `false` by default."
          },
          "max_output_buffer_size_records": {
            "type": "integer",
            "description": "Maximum number of updates to be kept in the output buffer.\n\nThis parameter bounds the maximal size of the buffer.\nNote that the size of the buffer is not always equal to the\ntotal number of updates output by the pipeline. Updates to the\nsame record can overwrite or cancel previous updates.\n\nBy default, the buffer can grow indefinitely until one of\nthe other output conditions is satisfied.\n\nNOTE: this configuration option requires the `enable_output_buffer` flag\nto be set.",
            "minimum": 0
          },
          "max_output_buffer_time_millis": {
            "type": "integer",
            "description": "Maximum time in milliseconds data is kept in the output buffer.\n\nBy default, data is kept in the buffer indefinitely until one of\nthe other output conditions is satisfied.  When this option is\nset the buffer will be flushed at most every\n`max_output_buffer_time_millis` milliseconds.\n\nNOTE: this configuration option requires the `enable_output_buffer` flag\nto be set.",
            "minimum": 0
          }
        }
      },
      "OutputEndpointConfig": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ConnectorConfig"
          },
          {
            "type": "object",
            "required": [
              "stream"
            ],
            "properties": {
              "stream": {
                "type": "string",
                "description": "The name of the output stream of the circuit that this endpoint is\nconnected to."
              }
            }
          }
        ],
        "description": "Describes an output connector configuration"
      },
      "OutputQuery": {
        "type": "string",
        "description": "A query over an output stream.\n\nWe currently do not support ad hoc queries.  Instead the client can use\nthree pre-defined queries to inspect the contents of a table or view.",
        "enum": [
          "table",
          "neighborhood",
          "quantiles"
        ]
      },
      "ParquetEncoderConfig": {
        "type": "object",
        "properties": {
          "buffer_size_records": {
            "type": "integer",
            "description": "Number of records before a new parquet file is written.\n\nThe default is 100_000.",
            "minimum": 0
          }
        }
      },
      "ParquetParserConfig": {
        "type": "object",
        "description": "Configuration for the parquet parser."
      },
      "Pipeline": {
        "type": "object",
        "description": "State of a pipeline, including static configuration\nand runtime status.",
        "required": [
          "descriptor",
          "state"
        ],
        "properties": {
          "descriptor": {
            "$ref": "#/components/schemas/PipelineDescr"
          },
          "state": {
            "$ref": "#/components/schemas/PipelineRuntimeState"
          }
        }
      },
      "PipelineConfig": {
        "allOf": [
          {
            "type": "object",
            "description": "Global pipeline configuration settings. This is the publicly\nexposed type for users to configure pipelines.",
            "properties": {
              "cpu_profiler": {
                "type": "boolean",
                "description": "Enable CPU profiler."
              },
              "max_buffering_delay_usecs": {
                "type": "integer",
                "format": "int64",
                "description": "Maximal delay in microseconds to wait for `min_batch_size_records` to\nget buffered by the controller, defaults to 0.",
                "minimum": 0
              },
              "min_batch_size_records": {
                "type": "integer",
                "format": "int64",
                "description": "Minimal input batch size.\n\nThe controller delays pushing input records to the circuit until at\nleast `min_batch_size_records` records have been received (total\nacross all endpoints) or `max_buffering_delay_usecs` microseconds\nhave passed since at least one input records has been buffered.\nDefaults to 0.",
                "minimum": 0
              },
              "min_storage_rows": {
                "type": "integer",
                "description": "The minimum estimated number of rows in a batch to write it to storage.\nThis is provided for debugging and fine-tuning and should ordinarily be\nleft unset. It only has an effect when `storage` is set to true.\n\nA value of 0 will write even empty batches to storage, and nonzero\nvalues provide a threshold.  `usize::MAX` would effectively disable\nstorage.",
                "nullable": true,
                "minimum": 0
              },
              "resources": {
                "$ref": "#/components/schemas/ResourceConfig"
              },
              "storage": {
                "type": "boolean",
                "description": "Should persistent storage be enabled for this pipeline?\n\n- If `false` (default), the pipeline's state is kept in in-memory data-structures.\nThis is useful if the pipeline is ephemeral and does not need to be recovered\nafter a restart. The pipeline will most likely run faster since it does not\nneed to read from, or write to disk\n\n- If `true`, the pipeline state is stored in the specified location,\nis persisted across restarts, and can be checkpointed and recovered.\nThis feature is currently experimental."
              },
              "tcp_metrics_exporter": {
                "type": "boolean",
                "description": "Enable the TCP metrics exporter.\n\nThis is used for development purposes only.\nIf enabled, the `metrics-observer` CLI tool\ncan be used to inspect metrics from the pipeline.\n\nBecause of how Rust metrics work, this is only honored for the first\npipeline to be instantiated within a given process."
              },
              "workers": {
                "type": "integer",
                "format": "int32",
                "description": "Number of DBSP worker threads.",
                "minimum": 0
              }
            }
          },
          {
            "type": "object",
            "required": [
              "inputs"
            ],
            "properties": {
              "inputs": {
                "type": "object",
                "description": "Input endpoint configuration.",
                "additionalProperties": {
                  "$ref": "#/components/schemas/InputEndpointConfig"
                }
              },
              "name": {
                "type": "string",
                "description": "Pipeline name.",
                "nullable": true
              },
              "outputs": {
                "type": "object",
                "description": "Output endpoint configuration.",
                "additionalProperties": {
                  "$ref": "#/components/schemas/OutputEndpointConfig"
                }
              },
              "storage_config": {
                "allOf": [
                  {
                    "$ref": "#/components/schemas/StorageConfig"
                  }
                ],
                "nullable": true
              }
            }
          }
        ],
        "description": "Pipeline configuration specified by the user when creating\na new pipeline instance.\n\nThis is the shape of the overall pipeline configuration. It encapsulates a\n[`RuntimeConfig`], which is the publicly exposed way for users to configure\npipelines."
      },
      "PipelineDescr": {
        "type": "object",
        "description": "Pipeline descriptor.",
        "required": [
          "pipeline_id",
          "version",
          "name",
          "description",
          "config",
          "attached_connectors"
        ],
        "properties": {
          "attached_connectors": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AttachedConnector"
            }
          },
          "config": {
            "$ref": "#/components/schemas/RuntimeConfig"
          },
          "description": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "pipeline_id": {
            "$ref": "#/components/schemas/PipelineId"
          },
          "program_name": {
            "type": "string",
            "nullable": true
          },
          "version": {
            "$ref": "#/components/schemas/Version"
          }
        }
      },
      "PipelineId": {
        "type": "string",
        "format": "uuid",
        "description": "Unique pipeline id."
      },
      "PipelineRevision": {
        "type": "object",
        "description": "A pipeline revision is a versioned, immutable configuration struct that\ncontains all information necessary to run a pipeline.",
        "required": [
          "revision",
          "pipeline",
          "connectors",
          "services_for_connectors",
          "program",
          "config"
        ],
        "properties": {
          "config": {
            "$ref": "#/components/schemas/PipelineConfig"
          },
          "connectors": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ConnectorDescr"
            },
            "description": "The versioned connectors."
          },
          "pipeline": {
            "$ref": "#/components/schemas/PipelineDescr"
          },
          "program": {
            "$ref": "#/components/schemas/ProgramDescr"
          },
          "revision": {
            "$ref": "#/components/schemas/Revision"
          },
          "services_for_connectors": {
            "type": "array",
            "items": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/ServiceDescr"
              }
            },
            "description": "The versioned services for each connector."
          }
        }
      },
      "PipelineRuntimeState": {
        "type": "object",
        "description": "Runtime state of the pipeine.",
        "required": [
          "pipeline_id",
          "location",
          "desired_status",
          "current_status",
          "status_since",
          "created"
        ],
        "properties": {
          "created": {
            "type": "string",
            "format": "date-time",
            "description": "Time when the pipeline started executing."
          },
          "current_status": {
            "$ref": "#/components/schemas/PipelineStatus"
          },
          "desired_status": {
            "$ref": "#/components/schemas/PipelineStatus"
          },
          "error": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ErrorResponse"
              }
            ],
            "nullable": true
          },
          "location": {
            "type": "string",
            "description": "Location where the pipeline can be reached at runtime.\ne.g., a TCP port number or a URI."
          },
          "pipeline_id": {
            "$ref": "#/components/schemas/PipelineId"
          },
          "status_since": {
            "type": "string",
            "format": "date-time",
            "description": "Time when the pipeline was assigned its current status\nof the pipeline."
          }
        }
      },
      "PipelineStatus": {
        "type": "string",
        "description": "Pipeline status.\n\nThis type represents the state of the pipeline tracked by the pipeline\nrunner and observed by the API client via the `GET /pipeline` endpoint.\n\n### The lifecycle of a pipeline\n\nThe following automaton captures the lifecycle of the pipeline.  Individual\nstates and transitions of the automaton are described below.\n\n* In addition to the transitions shown in the diagram, all states have an\nimplicit \"forced shutdown\" transition to the `Shutdown` state.  This\ntransition is triggered when the pipeline runner is unable to communicate\nwith the pipeline and thereby forces a shutdown.\n\n* States labeled with the hourglass symbol () are **timed** states.  The\nautomaton stays in timed state until the corresponding operation completes\nor until the runner performs a forced shutdown of the pipeline after a\npre-defined timeout perioud.\n\n* State transitions labeled with API endpoint names (`/deploy`, `/start`,\n`/pause`, `/shutdown`) are triggered by invoking corresponding endpoint,\ne.g., `POST /v0/pipelines/{pipeline_id}/start`.\n\n```text\nShutdown\n         \n/deploy         \n   ShuttingDown\n         \nProvisioning    \n         \nProvisioned                 \n         /shutdown\nInitializing    \n         \n\n                   \n      Paused        \n                  \n/start    /pause  \n                  \n     Running        \n\n\n\nFailed\n```\n\n### Desired and actual status\n\nWe use the desired state model to manage the lifecycle of a pipeline.\nIn this model, the pipeline has two status attributes associated with\nit at runtime: the **desired** status, which represents what the user\nwould like the pipeline to do, and the **current** status, which\nrepresents the actual state of the pipeline.  The pipeline runner\nservice continuously monitors both fields and steers the pipeline\ntowards the desired state specified by the user.\nOnly three of the states in the pipeline automaton above can be\nused as desired statuses: `Paused`, `Running`, and `Shutdown`.\nThese statuses are selected by invoking REST endpoints shown\nin the diagram.\n\nThe user can monitor the current state of the pipeline via the\n`/status` endpoint, which returns an object of type `Pipeline`.\nIn a typical scenario, the user first sets\nthe desired state, e.g., by invoking the `/deploy` endpoint, and\nthen polls the `GET /pipeline` endpoint to monitor the actual status\nof the pipeline until its `state.current_status` attribute changes\nto \"paused\" indicating that the pipeline has been successfully\ninitialized, or \"failed\", indicating an error.",
        "enum": [
          "Shutdown",
          "Provisioning",
          "Initializing",
          "Paused",
          "Running",
          "ShuttingDown",
          "Failed"
        ]
      },
      "ProgramConfig": {
        "type": "object",
        "description": "Program configuration.",
        "properties": {
          "profile": {
            "allOf": [
              {
                "$ref": "#/components/schemas/CompilationProfile"
              }
            ],
            "nullable": true
          }
        }
      },
      "ProgramDescr": {
        "type": "object",
        "description": "Program descriptor.",
        "required": [
          "program_id",
          "name",
          "description",
          "version",
          "status",
          "config"
        ],
        "properties": {
          "code": {
            "type": "string",
            "description": "SQL code",
            "nullable": true
          },
          "config": {
            "$ref": "#/components/schemas/ProgramConfig"
          },
          "description": {
            "type": "string",
            "description": "Program description."
          },
          "name": {
            "type": "string",
            "description": "Program name (doesn't have to be unique)."
          },
          "program_id": {
            "$ref": "#/components/schemas/ProgramId"
          },
          "schema": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ProgramSchema"
              }
            ],
            "nullable": true
          },
          "status": {
            "$ref": "#/components/schemas/ProgramStatus"
          },
          "version": {
            "$ref": "#/components/schemas/Version"
          }
        }
      },
      "ProgramId": {
        "type": "string",
        "format": "uuid",
        "description": "Unique program id."
      },
      "ProgramSchema": {
        "type": "object",
        "description": "A struct containing the tables (inputs) and views for a program.\n\nParse from the JSON data-type of the DDL generated by the SQL compiler.",
        "required": [
          "inputs",
          "outputs"
        ],
        "properties": {
          "inputs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Relation"
            }
          },
          "outputs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Relation"
            }
          }
        }
      },
      "ProgramStatus": {
        "oneOf": [
          {
            "type": "string",
            "description": "Compilation request received from the user; program has been placed\nin the queue.",
            "enum": [
              "Pending"
            ]
          },
          {
            "type": "string",
            "description": "Compilation of SQL -> Rust in progress.",
            "enum": [
              "CompilingSql"
            ]
          },
          {
            "type": "string",
            "description": "Compiling Rust -> executable in progress.",
            "enum": [
              "CompilingRust"
            ]
          },
          {
            "type": "string",
            "description": "Compilation succeeded.",
            "enum": [
              "Success"
            ]
          },
          {
            "type": "object",
            "required": [
              "SqlError"
            ],
            "properties": {
              "SqlError": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/SqlCompilerMessage"
                },
                "description": "SQL compiler returned an error."
              }
            }
          },
          {
            "type": "object",
            "required": [
              "RustError"
            ],
            "properties": {
              "RustError": {
                "type": "string",
                "description": "Rust compiler returned an error."
              }
            }
          },
          {
            "type": "object",
            "required": [
              "SystemError"
            ],
            "properties": {
              "SystemError": {
                "type": "string",
                "description": "System/OS returned an error when trying to invoke commands."
              }
            }
          }
        ],
        "description": "Program compilation status."
      },
      "ProviderAwsCognito": {
        "type": "object",
        "required": [
          "jwk_uri",
          "login_url",
          "logout_url"
        ],
        "properties": {
          "jwk_uri": {
            "type": "string"
          },
          "login_url": {
            "type": "string"
          },
          "logout_url": {
            "type": "string"
          }
        }
      },
      "ProviderGoogleIdentity": {
        "type": "object",
        "required": [
          "jwk_uri",
          "client_id"
        ],
        "properties": {
          "client_id": {
            "type": "string"
          },
          "jwk_uri": {
            "type": "string"
          }
        }
      },
      "ReadStrategy": {
        "oneOf": [
          {
            "type": "object",
            "description": "Read a single object specified by a key",
            "required": [
              "key",
              "type"
            ],
            "properties": {
              "key": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "SingleKey"
                ]
              }
            }
          },
          {
            "type": "object",
            "description": "Read all objects whose keys match a prefix",
            "required": [
              "prefix",
              "type"
            ],
            "properties": {
              "prefix": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "Prefix"
                ]
              }
            }
          }
        ],
        "description": "Strategy that determines which objects to read from a given bucket",
        "discriminator": {
          "propertyName": "type"
        }
      },
      "Relation": {
        "type": "object",
        "description": "A SQL table or view. It has a name and a list of fields.\n\nMatches the Calcite JSON format.",
        "required": [
          "name",
          "fields"
        ],
        "properties": {
          "case_sensitive": {
            "type": "boolean"
          },
          "fields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/Field"
            }
          },
          "name": {
            "type": "string"
          }
        }
      },
      "ResourceConfig": {
        "type": "object",
        "properties": {
          "cpu_cores_max": {
            "type": "integer",
            "format": "int64",
            "description": "The maximum number of CPU cores to reserve\nfor an instance of this pipeline",
            "nullable": true,
            "minimum": 0
          },
          "cpu_cores_min": {
            "type": "integer",
            "format": "int64",
            "description": "The minimum number of CPU cores to reserve\nfor an instance of this pipeline",
            "nullable": true,
            "minimum": 0
          },
          "memory_mb_max": {
            "type": "integer",
            "format": "int64",
            "description": "The maximum memory in Megabytes to reserve\nfor an instance of this pipeline",
            "nullable": true,
            "minimum": 0
          },
          "memory_mb_min": {
            "type": "integer",
            "format": "int64",
            "description": "The minimum memory in Megabytes to reserve\nfor an instance of this pipeline",
            "nullable": true,
            "minimum": 0
          },
          "storage_class": {
            "type": "string",
            "description": "Storage class to use for an instance of this pipeline.\nThe class determines storage performance such as IOPS and throughput.",
            "nullable": true
          },
          "storage_mb_max": {
            "type": "integer",
            "format": "int64",
            "description": "The total storage in Megabytes to reserve\nfor an instance of this pipeline",
            "nullable": true,
            "minimum": 0
          }
        }
      },
      "Revision": {
        "type": "string",
        "format": "uuid",
        "description": "Revision number."
      },
      "RuntimeConfig": {
        "type": "object",
        "description": "Global pipeline configuration settings. This is the publicly\nexposed type for users to configure pipelines.",
        "properties": {
          "cpu_profiler": {
            "type": "boolean",
            "description": "Enable CPU profiler."
          },
          "max_buffering_delay_usecs": {
            "type": "integer",
            "format": "int64",
            "description": "Maximal delay in microseconds to wait for `min_batch_size_records` to\nget buffered by the controller, defaults to 0.",
            "minimum": 0
          },
          "min_batch_size_records": {
            "type": "integer",
            "format": "int64",
            "description": "Minimal input batch size.\n\nThe controller delays pushing input records to the circuit until at\nleast `min_batch_size_records` records have been received (total\nacross all endpoints) or `max_buffering_delay_usecs` microseconds\nhave passed since at least one input records has been buffered.\nDefaults to 0.",
            "minimum": 0
          },
          "min_storage_rows": {
            "type": "integer",
            "description": "The minimum estimated number of rows in a batch to write it to storage.\nThis is provided for debugging and fine-tuning and should ordinarily be\nleft unset. It only has an effect when `storage` is set to true.\n\nA value of 0 will write even empty batches to storage, and nonzero\nvalues provide a threshold.  `usize::MAX` would effectively disable\nstorage.",
            "nullable": true,
            "minimum": 0
          },
          "resources": {
            "$ref": "#/components/schemas/ResourceConfig"
          },
          "storage": {
            "type": "boolean",
            "description": "Should persistent storage be enabled for this pipeline?\n\n- If `false` (default), the pipeline's state is kept in in-memory data-structures.\nThis is useful if the pipeline is ephemeral and does not need to be recovered\nafter a restart. The pipeline will most likely run faster since it does not\nneed to read from, or write to disk\n\n- If `true`, the pipeline state is stored in the specified location,\nis persisted across restarts, and can be checkpointed and recovered.\nThis feature is currently experimental."
          },
          "tcp_metrics_exporter": {
            "type": "boolean",
            "description": "Enable the TCP metrics exporter.\n\nThis is used for development purposes only.\nIf enabled, the `metrics-observer` CLI tool\ncan be used to inspect metrics from the pipeline.\n\nBecause of how Rust metrics work, this is only honored for the first\npipeline to be instantiated within a given process."
          },
          "workers": {
            "type": "integer",
            "format": "int32",
            "description": "Number of DBSP worker threads.",
            "minimum": 0
          }
        }
      },
      "S3InputConfig": {
        "type": "object",
        "description": "Configuration for reading data from AWS S3.",
        "required": [
          "credentials",
          "region",
          "bucket_name",
          "read_strategy"
        ],
        "properties": {
          "bucket_name": {
            "type": "string",
            "description": "S3 bucket name to access"
          },
          "consume_strategy": {
            "$ref": "#/components/schemas/ConsumeStrategy"
          },
          "credentials": {
            "$ref": "#/components/schemas/AwsCredentials"
          },
          "read_strategy": {
            "$ref": "#/components/schemas/ReadStrategy"
          },
          "region": {
            "type": "string",
            "description": "AWS region"
          }
        }
      },
      "ServiceConfig": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "kafka"
            ],
            "properties": {
              "kafka": {
                "$ref": "#/components/schemas/KafkaService"
              }
            }
          }
        ],
        "description": "Configuration for a Service, which typically includes how to establish a\nconnection (e.g., hostname, port) and authenticate (e.g., credentials).\n\nThis configuration can be used to easily derive connectors for the service\nas well as probe it for information."
      },
      "ServiceDescr": {
        "type": "object",
        "description": "Service descriptor.",
        "required": [
          "service_id",
          "name",
          "description",
          "config",
          "config_type"
        ],
        "properties": {
          "config": {
            "$ref": "#/components/schemas/ServiceConfig"
          },
          "config_type": {
            "type": "string"
          },
          "description": {
            "type": "string"
          },
          "name": {
            "type": "string"
          },
          "service_id": {
            "$ref": "#/components/schemas/ServiceId"
          }
        }
      },
      "ServiceId": {
        "type": "string",
        "format": "uuid",
        "description": "Unique service id."
      },
      "ServiceProbeDescr": {
        "type": "object",
        "description": "Service probe descriptor.",
        "required": [
          "service_probe_id",
          "status",
          "probe_type",
          "request",
          "created_at"
        ],
        "properties": {
          "created_at": {
            "type": "string",
            "format": "date-time"
          },
          "finished_at": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "probe_type": {
            "$ref": "#/components/schemas/ServiceProbeType"
          },
          "request": {
            "$ref": "#/components/schemas/ServiceProbeRequest"
          },
          "response": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ServiceProbeResponse"
              }
            ],
            "nullable": true
          },
          "service_probe_id": {
            "$ref": "#/components/schemas/ServiceProbeId"
          },
          "started_at": {
            "type": "string",
            "format": "date-time",
            "nullable": true
          },
          "status": {
            "$ref": "#/components/schemas/ServiceProbeStatus"
          }
        }
      },
      "ServiceProbeError": {
        "oneOf": [
          {
            "type": "string",
            "enum": [
              "timeout_exceeded"
            ]
          },
          {
            "type": "object",
            "required": [
              "unsupported_request"
            ],
            "properties": {
              "unsupported_request": {
                "type": "object",
                "required": [
                  "service_type",
                  "probe_type"
                ],
                "properties": {
                  "probe_type": {
                    "type": "string"
                  },
                  "service_type": {
                    "type": "string"
                  }
                }
              }
            }
          },
          {
            "type": "object",
            "required": [
              "other"
            ],
            "properties": {
              "other": {
                "type": "string"
              }
            }
          }
        ],
        "description": "Range of possible errors that can occur during a service probe.\nThese are shared across all services."
      },
      "ServiceProbeId": {
        "type": "string",
        "format": "uuid",
        "description": "Unique service probe id."
      },
      "ServiceProbeRequest": {
        "type": "string",
        "description": "Enumeration of all possible service probe requests.",
        "enum": [
          "test_connectivity",
          "kafka_get_topics"
        ]
      },
      "ServiceProbeResponse": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "success"
            ],
            "properties": {
              "success": {
                "$ref": "#/components/schemas/ServiceProbeResult"
              }
            }
          },
          {
            "type": "object",
            "required": [
              "error"
            ],
            "properties": {
              "error": {
                "$ref": "#/components/schemas/ServiceProbeError"
              }
            }
          }
        ],
        "description": "Response being either success or error."
      },
      "ServiceProbeResult": {
        "oneOf": [
          {
            "type": "string",
            "description": "A connection to the service was established.",
            "enum": [
              "connected"
            ]
          },
          {
            "type": "object",
            "required": [
              "kafka_topics"
            ],
            "properties": {
              "kafka_topics": {
                "type": "array",
                "items": {
                  "type": "string"
                },
                "description": "The names of all Kafka topics of the service."
              }
            }
          }
        ],
        "description": "Enumeration of all possible service probe success responses."
      },
      "ServiceProbeStatus": {
        "type": "string",
        "description": "Service probe status.\n\nState transition diagram:\n```text\nPending\n\n (Prober server picks up the probe)\n\n\nRunning  Failure\n\n\nSuccess\n```",
        "enum": [
          "pending",
          "running",
          "success",
          "failure"
        ]
      },
      "ServiceProbeType": {
        "type": "string",
        "description": "Enumeration of all possible service probe types.\nEach type maps to exactly one request variant.",
        "enum": [
          "test_connectivity",
          "kafka_get_topics"
        ]
      },
      "SqlCompilerMessage": {
        "type": "object",
        "description": "A SQL compiler error.\n\nThe SQL compiler returns a list of errors in the following JSON format if\nit's invoked with the `-je` option.\n\n```ignore\n[ {\n\"startLineNumber\" : 14,\n\"startColumn\" : 13,\n\"endLineNumber\" : 14,\n\"endColumn\" : 13,\n\"warning\" : false,\n\"errorType\" : \"Error parsing SQL\",\n\"message\" : \"Encountered \\\"<EOF>\\\" at line 14, column 13.\"\n} ]\n```",
        "required": [
          "startLineNumber",
          "startColumn",
          "endLineNumber",
          "endColumn",
          "warning",
          "errorType",
          "message"
        ],
        "properties": {
          "endColumn": {
            "type": "integer",
            "minimum": 0
          },
          "endLineNumber": {
            "type": "integer",
            "minimum": 0
          },
          "errorType": {
            "type": "string"
          },
          "message": {
            "type": "string"
          },
          "startColumn": {
            "type": "integer",
            "minimum": 0
          },
          "startLineNumber": {
            "type": "integer",
            "minimum": 0
          },
          "warning": {
            "type": "boolean"
          }
        }
      },
      "SqlType": {
        "oneOf": [
          {
            "type": "string",
            "description": "SQL `BOOLEAN` type.",
            "enum": [
              "BOOLEAN"
            ]
          },
          {
            "type": "string",
            "description": "SQL `TINYINT` type.",
            "enum": [
              "TINYINT"
            ]
          },
          {
            "type": "string",
            "description": "SQL `SMALLINT` or `INT2` type.",
            "enum": [
              "SMALLINT"
            ]
          },
          {
            "type": "string",
            "description": "SQL `INTEGER`, `INT`, `SIGNED`, `INT4` type.",
            "enum": [
              "INTEGER"
            ]
          },
          {
            "type": "string",
            "description": "SQL `BIGINT` or `INT64` type.",
            "enum": [
              "BIGINT"
            ]
          },
          {
            "type": "string",
            "description": "SQL `REAL` or `FLOAT4` or `FLOAT32` type.",
            "enum": [
              "REAL"
            ]
          },
          {
            "type": "string",
            "description": "SQL `DOUBLE` or `FLOAT8` or `FLOAT64` type.",
            "enum": [
              "DOUBLE"
            ]
          },
          {
            "type": "string",
            "description": "SQL `DECIMAL` or `DEC` or `NUMERIC` type.",
            "enum": [
              "DECIMAL"
            ]
          },
          {
            "type": "string",
            "description": "SQL `CHAR(n)` or `CHARACTER(n)` type.",
            "enum": [
              "CHAR"
            ]
          },
          {
            "type": "string",
            "description": "SQL `VARCHAR`, `CHARACTER VARYING`, `TEXT`, or `STRING` type.",
            "enum": [
              "VARCHAR"
            ]
          },
          {
            "type": "string",
            "description": "SQL `BINARY(n)` type.",
            "enum": [
              "BINARY"
            ]
          },
          {
            "type": "string",
            "description": "SQL `VARBINARY` or `BYTEA` type.",
            "enum": [
              "VARBINARY"
            ]
          },
          {
            "type": "string",
            "description": "SQL `TIME` type.",
            "enum": [
              "TIME"
            ]
          },
          {
            "type": "string",
            "description": "SQL `DATE` type.",
            "enum": [
              "DATE"
            ]
          },
          {
            "type": "string",
            "description": "SQL `TIMESTAMP` type.",
            "enum": [
              "TIMESTAMP"
            ]
          },
          {
            "type": "object",
            "required": [
              "Interval"
            ],
            "properties": {
              "Interval": {
                "$ref": "#/components/schemas/IntervalUnit"
              }
            }
          },
          {
            "type": "string",
            "description": "SQL `ARRAY` type.",
            "enum": [
              "ARRAY"
            ]
          },
          {
            "type": "string",
            "description": "A complex SQL struct type (`CREATE TYPE x ...`).",
            "enum": [
              "STRUCT"
            ]
          },
          {
            "type": "string",
            "description": "SQL `NULL` type.",
            "enum": [
              "NULL"
            ]
          }
        ],
        "description": "The available SQL types as specified in `CREATE` statements."
      },
      "StorageCacheConfig": {
        "type": "string",
        "description": "How to cache access to storage within a Feldera pipeline.",
        "enum": [
          "page_cache",
          "feldera_cache"
        ]
      },
      "StorageConfig": {
        "type": "object",
        "description": "Configuration for persistent storage in a [`PipelineConfig`].",
        "required": [
          "path",
          "cache"
        ],
        "properties": {
          "cache": {
            "$ref": "#/components/schemas/StorageCacheConfig"
          },
          "path": {
            "type": "string",
            "description": "The location where the pipeline state is stored or will be stored.\n\nIt should point to a path on the file-system of the machine/container\nwhere the pipeline will run. If that path doesn't exist yet, or if it\ndoes not contain any checkpoints, then the pipeline creates it and\nstarts from an initial state in which no data has yet been received. If\nit does exist, then the pipeline starts from the most recent checkpoint\nthat already exists there. In either case, (further) checkpoints will be\nwritten there."
          }
        }
      },
      "TenantId": {
        "type": "string",
        "format": "uuid"
      },
      "TransportConfig": {
        "oneOf": [
          {
            "type": "object",
            "required": [
              "name",
              "config"
            ],
            "properties": {
              "config": {
                "$ref": "#/components/schemas/FileInputConfig"
              },
              "name": {
                "type": "string",
                "enum": [
                  "file_input"
                ]
              }
            }
          },
          {
            "type": "object",
            "required": [
              "name",
              "config"
            ],
            "properties": {
              "config": {
                "$ref": "#/components/schemas/FileOutputConfig"
              },
              "name": {
                "type": "string",
                "enum": [
                  "file_output"
                ]
              }
            }
          },
          {
            "type": "object",
            "required": [
              "name",
              "config"
            ],
            "properties": {
              "config": {
                "$ref": "#/components/schemas/KafkaInputConfig"
              },
              "name": {
                "type": "string",
                "enum": [
                  "kafka_input"
                ]
              }
            }
          },
          {
            "type": "object",
            "required": [
              "name",
              "config"
            ],
            "properties": {
              "config": {
                "$ref": "#/components/schemas/KafkaOutputConfig"
              },
              "name": {
                "type": "string",
                "enum": [
                  "kafka_output"
                ]
              }
            }
          },
          {
            "type": "object",
            "required": [
              "name",
              "config"
            ],
            "properties": {
              "config": {
                "$ref": "#/components/schemas/UrlInputConfig"
              },
              "name": {
                "type": "string",
                "enum": [
                  "url_input"
                ]
              }
            }
          },
          {
            "type": "object",
            "required": [
              "name",
              "config"
            ],
            "properties": {
              "config": {
                "$ref": "#/components/schemas/S3InputConfig"
              },
              "name": {
                "type": "string",
                "enum": [
                  "s3_input"
                ]
              }
            }
          },
          {
            "type": "object",
            "required": [
              "name",
              "config"
            ],
            "properties": {
              "config": {
                "$ref": "#/components/schemas/DeltaTableReaderConfig"
              },
              "name": {
                "type": "string",
                "enum": [
                  "delta_table_input"
                ]
              }
            }
          },
          {
            "type": "object",
            "required": [
              "name",
              "config"
            ],
            "properties": {
              "config": {
                "$ref": "#/components/schemas/DeltaTableWriterConfig"
              },
              "name": {
                "type": "string",
                "enum": [
                  "delta_table_output"
                ]
              }
            }
          },
          {
            "type": "object",
            "required": [
              "name"
            ],
            "properties": {
              "name": {
                "type": "string",
                "enum": [
                  "http_input"
                ]
              }
            }
          },
          {
            "type": "object",
            "required": [
              "name"
            ],
            "properties": {
              "name": {
                "type": "string",
                "enum": [
                  "http_output"
                ]
              }
            }
          }
        ],
        "description": "Transport-specific endpoint configuration passed to\n`crate::OutputTransport::new_endpoint`\nand `crate::InputTransport::new_endpoint`.",
        "discriminator": {
          "propertyName": "name"
        }
      },
      "UpdateConnectorRequest": {
        "type": "object",
        "description": "Request to update an existing connector.",
        "properties": {
          "config": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ConnectorConfig"
              }
            ],
            "nullable": true
          },
          "description": {
            "type": "string",
            "description": "New connector description. If absent, existing name will be kept\nunmodified.",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "New connector name. If absent, existing name will be kept unmodified.",
            "nullable": true
          }
        }
      },
      "UpdateConnectorResponse": {
        "type": "object",
        "description": "Response to a connector update request."
      },
      "UpdatePipelineRequest": {
        "type": "object",
        "description": "Request to update an existing pipeline.",
        "required": [
          "name",
          "description"
        ],
        "properties": {
          "config": {
            "allOf": [
              {
                "$ref": "#/components/schemas/RuntimeConfig"
              }
            ],
            "nullable": true
          },
          "connectors": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/AttachedConnector"
            },
            "description": "Attached connectors.\n\n- If absent, existing connectors will be kept unmodified.\n\n- If present all existing connectors will be replaced with the new\nspecified list.",
            "nullable": true
          },
          "description": {
            "type": "string",
            "description": "New pipeline description."
          },
          "name": {
            "type": "string",
            "description": "New pipeline name."
          },
          "program_name": {
            "type": "string",
            "description": "New program to create a pipeline for. If absent, program will be set to\nNULL.",
            "nullable": true
          }
        },
        "additionalProperties": false
      },
      "UpdatePipelineResponse": {
        "type": "object",
        "description": "Response to a config update request.",
        "required": [
          "version"
        ],
        "properties": {
          "version": {
            "$ref": "#/components/schemas/Version"
          }
        }
      },
      "UpdateProgramRequest": {
        "type": "object",
        "description": "Request to update an existing program.",
        "properties": {
          "code": {
            "type": "string",
            "description": "New SQL code for the program. If absent, existing program code will be\nkept unmodified.",
            "nullable": true
          },
          "config": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ProgramConfig"
              }
            ],
            "nullable": true
          },
          "description": {
            "type": "string",
            "description": "New program description. If absent, existing description will be kept\nunmodified.",
            "nullable": true
          },
          "guard": {
            "allOf": [
              {
                "$ref": "#/components/schemas/Version"
              }
            ],
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "New program name. If absent, existing name will be kept unmodified.",
            "nullable": true
          }
        }
      },
      "UpdateProgramResponse": {
        "type": "object",
        "description": "Response to a program update request.",
        "required": [
          "version"
        ],
        "properties": {
          "version": {
            "$ref": "#/components/schemas/Version"
          }
        }
      },
      "UpdateServiceRequest": {
        "type": "object",
        "description": "Request to update an existing service.",
        "properties": {
          "config": {
            "allOf": [
              {
                "$ref": "#/components/schemas/ServiceConfig"
              }
            ],
            "nullable": true
          },
          "description": {
            "type": "string",
            "description": "New service description. If absent, existing name will be kept\nunmodified.",
            "nullable": true
          },
          "name": {
            "type": "string",
            "description": "New service name. If absent, existing name will be kept unmodified.",
            "nullable": true
          }
        }
      },
      "UpdateServiceResponse": {
        "type": "object",
        "description": "Response to a service update request."
      },
      "UrlInputConfig": {
        "type": "object",
        "description": "Configuration for reading data from an HTTP or HTTPS URL with\n`UrlInputTransport`.",
        "required": [
          "path"
        ],
        "properties": {
          "path": {
            "type": "string",
            "description": "URL."
          }
        }
      },
      "Version": {
        "type": "integer",
        "format": "int64",
        "description": "Version number."
      }
    },
    "securitySchemes": {
      "JSON web token (JWT) or API key": {
        "type": "http",
        "scheme": "bearer",
        "bearerFormat": "JWT",
        "description": "Use a JWT token obtained via an OAuth2/OIDC\n                               login workflow or an API key obtained via\n                               the `/v0/api-keys` endpoint."
      }
    }
  },
  "tags": [
    {
      "name": "Manager",
      "description": "Configure system behavior"
    },
    {
      "name": "Programs",
      "description": "Manage programs"
    },
    {
      "name": "Pipelines",
      "description": "Manage pipelines"
    },
    {
      "name": "Connectors",
      "description": "Manage data connectors"
    },
    {
      "name": "Services",
      "description": "Manage services"
    }
  ]
}