<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>python.feldera.client API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>python.feldera.client</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from typing import Optional
import logging
import time

from feldera.config import Config
from feldera.connector import Connector
from feldera.attached_connector import AttachedConnector
from feldera.program import Program
from feldera.pipeline import Pipeline
from feldera._httprequests import HttpRequests


class Client:
    &#34;&#34;&#34;
    A client for the Feldera HTTP API

    A client instance is needed for every Feldera API method to know the location of
    Feldera and its permissions.
    &#34;&#34;&#34;

    def __init__(
            self,
            url: str,
            api_key: Optional[str] = None,
            timeout: Optional[int] = None,
    ) -&gt; None:
        &#34;&#34;&#34;
        :param url: The url to Feldera API (ex: https://try.feldera.com)
        :param api_key: The optional API key for Feldera
        :param timeout: (optional) The amount of time in seconds that the cient will wait for a response beforing timing
            out.
        &#34;&#34;&#34;

        self.config = Config(url, api_key, timeout)
        self.http = HttpRequests(self.config)

    def programs(self) -&gt; list[Program]:
        &#34;&#34;&#34;
        Get all programs
        &#34;&#34;&#34;
        resp = self.http.get(
            path=&#34;/programs&#34;,
        )

        return [
            Program(
                name=program.get(&#34;name&#34;),
                program=program.get(&#34;code&#34;),
                description=program.get(&#34;description&#34;),
            ) for program in resp
        ]

    def get_program(self, name: str, with_code: bool = False) -&gt; Program:
        &#34;&#34;&#34;
        Get a program by name
        :param name: The name of the program
        :param with_code: If True, the program code will be included in the response
        &#34;&#34;&#34;
        resp = self.http.get(
            path=f&#34;/programs/{name}&#34;,
            params={
                &#34;with_code&#34;: with_code,
            }
        )

        return Program(
            name=resp.get(&#34;name&#34;),
            program=resp.get(&#34;code&#34;),
            description=resp.get(&#34;description&#34;),
            status=resp.get(&#34;status&#34;),
            version=resp.get(&#34;version&#34;),
        )

    def compile_program(self, program: Program):
        &#34;&#34;&#34;
        Compiles a SQL program
        :param program: The program to compile
        &#34;&#34;&#34;
        body = {
            &#34;code&#34;: program.program,
            &#34;description&#34;: program.description or &#34;&#34;,
        }

        resp = self.http.put(
            path=f&#34;/programs/{program.name}&#34;,
            body=body,
        )
        program.id = resp.get(&#34;program_id&#34;)
        program.version = resp.get(&#34;version&#34;)

        while True:
            status = self.get_program(program.name).status

            if status == &#34;Success&#34;:
                break
            elif status != &#34;Pending&#34; and status != &#34;CompilingRust&#34; and status != &#34;CompilingSql&#34;:
                raise RuntimeError(f&#34;Failed program compilation with status {status}&#34;)

            logging.debug(&#34;still compiling %s, waiting for 5 more seconds&#34;, program.name)
            time.sleep(5)

    def delete_program(self, name: str):
        &#34;&#34;&#34;
        Deletes a program by name
        :param name: The name of the program
        &#34;&#34;&#34;

        self.http.delete(
            path=f&#34;/programs/{name}&#34;,
        )

    def connectors(self) -&gt; list[Connector]:
        &#34;&#34;&#34;
        Get all connectors
        &#34;&#34;&#34;

        resp = self.http.get(
            path=&#34;/connectors&#34;,
        )

        return [
            Connector(
                name=connector.get(&#34;name&#34;),
                description=connector.get(&#34;description&#34;),
                config=connector.get(&#34;config&#34;),
                id=connector.get(&#34;connector_id&#34;),
            ) for connector in resp
        ]

    def get_connector(self, name: str) -&gt; Connector:
        &#34;&#34;&#34;
        Get a connector by name
        :param name: The name of the connector
        &#34;&#34;&#34;

        resp = self.http.get(
            path=f&#34;/connectors/{name}&#34;,
        )

        return Connector(
            name=resp.get(&#34;name&#34;),
            description=resp.get(&#34;description&#34;),
            config=resp.get(&#34;config&#34;),
            id=resp.get(&#34;connector_id&#34;),
        )

    def create_connector(self, connector: Connector):
        &#34;&#34;&#34;
        Create a connector
        :param connector: The connector to create
        &#34;&#34;&#34;
        body = {
            &#34;description&#34;: connector.description or &#34;&#34;,
            &#34;config&#34;: connector.config
        }

        resp = self.http.put(
            path=f&#34;/connectors/{connector.name}&#34;,
            body=body,
        )

        connector.id = resp.get(&#34;connector_id&#34;)

    def delete_connector(self, name: str):
        &#34;&#34;&#34;
        Deletes a connector by name
        :param name: The name of the connector
        &#34;&#34;&#34;
        self.http.delete(
            path=f&#34;/connectors/{name}&#34;,
        )

    @staticmethod
    def __pipeline_from_dict(pipeline: dict) -&gt; Pipeline:
        attached_connectors = pipeline.get(&#34;attached_connectors&#34;)
        descriptor = pipeline.get(&#34;descriptor&#34;)
        return Pipeline(
            name=descriptor.get(&#34;name&#34;),
            program_name=descriptor.get(&#34;program_name&#34;),
            version=descriptor.get(&#34;version&#34;),
            description=descriptor.get(&#34;description&#34;),
            id=descriptor.get(&#34;id&#34;),
            config=descriptor.get(&#34;config&#34;),
            state=pipeline.get(&#34;state&#34;),
            attached_connectors=[
                AttachedConnector(
                    connector_name=con.get(&#34;connector_name&#34;),
                    is_input=con.get(&#34;is_input&#34;),
                    relation_name=con.get(&#34;relation_name&#34;),
                    name=con.get(&#34;name&#34;),
                )
                for con in attached_connectors
            ] if attached_connectors else []
        )

    def pipelines(self) -&gt; list[Pipeline]:
        &#34;&#34;&#34;
        Get all pipelines
        &#34;&#34;&#34;

        resp = self.http.get(
            path=&#34;/pipelines&#34;,
        )

        return [self.__pipeline_from_dict(pipeline) for pipeline in resp]

    def get_pipeline(self, name: str) -&gt; Pipeline:
        &#34;&#34;&#34;
        Get a pipeline by name
        &#34;&#34;&#34;

        resp = self.http.get(
            path=f&#34;/pipelines/{name}&#34;,
        )

        return self.__pipeline_from_dict(resp)

    def create_pipeline(self, pipeline: Pipeline):
        &#34;&#34;&#34;
        Create a pipeline
        &#34;&#34;&#34;

        body = {
            &#34;config&#34;: pipeline.config,
            &#34;description&#34;: pipeline.description or &#34;&#34;,
            &#34;connectors&#34;: pipeline.attached_connectors,
            &#34;program_name&#34;: pipeline.program_name,
        }

        resp = self.http.put(
            path=f&#34;/pipelines/{pipeline.name}&#34;,
            body=body,
        )

        pipeline.id = resp.get(&#34;pipeline_id&#34;)

    def get_pipeline_config(self, name: str) -&gt; dict:
        &#34;&#34;&#34;
        Get the configuration of a pipeline by name
        &#34;&#34;&#34;

        resp = self.http.get(
            path=f&#34;/pipelines/{name}/config&#34;,
        )

        return resp

    def validate_pipeline(self, name: str) -&gt; bool:
        &#34;&#34;&#34;
        Validate a pipeline.
        Checks whether the pipeline is configured correctly.
        This includes checking whether the pipeline references a valid compiled program,
        whether the connectors reference valid tables/views in the program, and more.
        &#34;&#34;&#34;

        resp = self.http.get(
            path=f&#34;/pipelines/{name}/validate&#34;,
        )

        return &#34;success&#34; in resp

    def delete_pipeline(self, name: str):
        &#34;&#34;&#34;
        Deletes a pipeline by name
        :param name: The name of the pipeline
        &#34;&#34;&#34;
        resp = self.http.delete(
            path=f&#34;/pipelines/{name}&#34;,
        )

    def get_pipeline_stats(self, name: str) -&gt; dict:
        &#34;&#34;&#34;
        Get the pipeline metrics and performance counters
        &#34;&#34;&#34;

        resp = self.http.get(
            path=f&#34;/pipelines/{name}/stats&#34;,
        )

        return resp

    def start_pipeline(self, pipeline_name: str):
        &#34;&#34;&#34;
        Start a pipeline
        :param pipeline_name: The name of the pipeline to start
        &#34;&#34;&#34;
        self.http.post(
            path=f&#34;/pipelines/{pipeline_name}/start&#34;,
        )

        while True:
            status = self.get_pipeline(pipeline_name).state.get(&#34;current_status&#34;)

            if status == &#34;Running&#34;:
                break
            elif status == &#34;Failed&#34;:
                raise RuntimeError(f&#34;Failed to start pipeline&#34;)

            logging.debug(&#34;still starting %s, waiting for 100 more milliseconds&#34;, pipeline_name)
            time.sleep(0.1)

    def pause_pipeline(self, pipeline_name: str):
        &#34;&#34;&#34;
        Stop a pipeline
        :param pipeline_name: The name of the pipeline to stop
        &#34;&#34;&#34;
        self.http.post(
            path=f&#34;/pipelines/{pipeline_name}/pause&#34;,
        )

        while True:
            status = self.get_pipeline(pipeline_name).state.get(&#34;current_status&#34;)

            if status == &#34;Paused&#34;:
                break
            elif status == &#34;Failed&#34;:
                raise RuntimeError(f&#34;Failed to pause pipeline&#34;)

            logging.debug(&#34;still pausing %s, waiting for 100 more milliseconds&#34;, pipeline_name)
            time.sleep(0.1)

    def shutdown_pipeline(self, pipeline_name: str):
        &#34;&#34;&#34;
        Shutdown a pipeline
        :param pipeline_name: The name of the pipeline to shutdown
        &#34;&#34;&#34;
        self.http.post(
            path=f&#34;/pipelines/{pipeline_name}/shutdown&#34;,
        )

        while True:
            status = self.get_pipeline(pipeline_name).state.get(&#34;current_status&#34;)

            if status == &#34;Shutdown&#34;:
                break
            elif status == &#34;Failed&#34;:
                raise RuntimeError(f&#34;Failed to shutdown pipeline&#34;)

            logging.debug(&#34;still shutting down %s, waiting for 100 more milliseconds&#34;, pipeline_name)
            time.sleep(0.1)

    # TODO: better name for this method
    def push_to_pipeline(
            self,
            pipeline_name: str,
            table_name: str,
            format: str,
            data: list[list | str | dict],
            array: bool = False,
            force: bool = False,
            update_format: str = &#34;raw&#34;,
    ):
        &#34;&#34;&#34;
        Insert data into a pipeline
        :param pipeline_name: The name of the pipeline
        :param table_name: The name of the table
        :param format: The format of the data, either &#34;json&#34; or &#34;csv&#34;
        :param array: Set True if updates in this stream are packed into JSON arrays, used in conjunction with the
            &#34;json&#34; format
        :param force: If True, the data will be inserted even if the pipeline is paused
        :param update_format: JSON data change event format, used in conjunction with the &#34;json&#34; format,
        the default value is &#34;insert_delete&#34;, other supported formats: &#34;weighted&#34;, &#34;debezium&#34;, &#34;snowflake&#34;, &#34;raw&#34;
        :param data: The data to insert
        &#34;&#34;&#34;

        if format not in [&#34;json&#34;, &#34;csv&#34;]:
            raise ValueError(&#34;format must be either &#39;json&#39; or &#39;csv&#39;&#34;)

        if update_format not in [&#34;insert_delete&#34;, &#34;weighted&#34;, &#34;debezium&#34;, &#34;snowflake&#34;, &#34;raw&#34;]:
            raise ValueError(&#34;update_format must be one of &#39;insert_delete&#39;, &#39;weighted&#39;, &#39;debezium&#39;, &#39;snowflake&#39;, &#39;raw&#39;&#34;)

        # python sends `True` which isn&#39;t accepted by the backend
        array = &#34;true&#34; if array else &#34;false&#34;
        force = &#34;true&#34; if force else &#34;false&#34;

        params = {
            &#34;force&#34;: force,
            &#34;format&#34;: format,
        }

        if format == &#34;json&#34;:
            params[&#34;array&#34;] = array
            params[&#34;update_format&#34;] = update_format

        content_type = &#34;application/json&#34;

        self.start_pipeline(pipeline_name)

        if format == &#34;csv&#34;:
            content_type = &#34;text/csv&#34;
            data = bytes(str(data), &#34;utf-8&#34;)

        self.http.post(
            path=f&#34;/pipelines/{pipeline_name}/ingress/{table_name}&#34;,
            params=params,
            content_type=content_type,
            body=data,
        )</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="python.feldera.client.Client"><code class="flex name class">
<span>class <span class="ident">Client</span></span>
<span>(</span><span>url: str, api_key: Optional[str] = None, timeout: Optional[int] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A client for the Feldera HTTP API</p>
<p>A client instance is needed for every Feldera API method to know the location of
Feldera and its permissions.</p>
<p>:param url: The url to Feldera API (ex: <a href="https://try.feldera.com">https://try.feldera.com</a>)
:param api_key: The optional API key for Feldera
:param timeout: (optional) The amount of time in seconds that the cient will wait for a response beforing timing
out.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Client:
    &#34;&#34;&#34;
    A client for the Feldera HTTP API

    A client instance is needed for every Feldera API method to know the location of
    Feldera and its permissions.
    &#34;&#34;&#34;

    def __init__(
            self,
            url: str,
            api_key: Optional[str] = None,
            timeout: Optional[int] = None,
    ) -&gt; None:
        &#34;&#34;&#34;
        :param url: The url to Feldera API (ex: https://try.feldera.com)
        :param api_key: The optional API key for Feldera
        :param timeout: (optional) The amount of time in seconds that the cient will wait for a response beforing timing
            out.
        &#34;&#34;&#34;

        self.config = Config(url, api_key, timeout)
        self.http = HttpRequests(self.config)

    def programs(self) -&gt; list[Program]:
        &#34;&#34;&#34;
        Get all programs
        &#34;&#34;&#34;
        resp = self.http.get(
            path=&#34;/programs&#34;,
        )

        return [
            Program(
                name=program.get(&#34;name&#34;),
                program=program.get(&#34;code&#34;),
                description=program.get(&#34;description&#34;),
            ) for program in resp
        ]

    def get_program(self, name: str, with_code: bool = False) -&gt; Program:
        &#34;&#34;&#34;
        Get a program by name
        :param name: The name of the program
        :param with_code: If True, the program code will be included in the response
        &#34;&#34;&#34;
        resp = self.http.get(
            path=f&#34;/programs/{name}&#34;,
            params={
                &#34;with_code&#34;: with_code,
            }
        )

        return Program(
            name=resp.get(&#34;name&#34;),
            program=resp.get(&#34;code&#34;),
            description=resp.get(&#34;description&#34;),
            status=resp.get(&#34;status&#34;),
            version=resp.get(&#34;version&#34;),
        )

    def compile_program(self, program: Program):
        &#34;&#34;&#34;
        Compiles a SQL program
        :param program: The program to compile
        &#34;&#34;&#34;
        body = {
            &#34;code&#34;: program.program,
            &#34;description&#34;: program.description or &#34;&#34;,
        }

        resp = self.http.put(
            path=f&#34;/programs/{program.name}&#34;,
            body=body,
        )
        program.id = resp.get(&#34;program_id&#34;)
        program.version = resp.get(&#34;version&#34;)

        while True:
            status = self.get_program(program.name).status

            if status == &#34;Success&#34;:
                break
            elif status != &#34;Pending&#34; and status != &#34;CompilingRust&#34; and status != &#34;CompilingSql&#34;:
                raise RuntimeError(f&#34;Failed program compilation with status {status}&#34;)

            logging.debug(&#34;still compiling %s, waiting for 5 more seconds&#34;, program.name)
            time.sleep(5)

    def delete_program(self, name: str):
        &#34;&#34;&#34;
        Deletes a program by name
        :param name: The name of the program
        &#34;&#34;&#34;

        self.http.delete(
            path=f&#34;/programs/{name}&#34;,
        )

    def connectors(self) -&gt; list[Connector]:
        &#34;&#34;&#34;
        Get all connectors
        &#34;&#34;&#34;

        resp = self.http.get(
            path=&#34;/connectors&#34;,
        )

        return [
            Connector(
                name=connector.get(&#34;name&#34;),
                description=connector.get(&#34;description&#34;),
                config=connector.get(&#34;config&#34;),
                id=connector.get(&#34;connector_id&#34;),
            ) for connector in resp
        ]

    def get_connector(self, name: str) -&gt; Connector:
        &#34;&#34;&#34;
        Get a connector by name
        :param name: The name of the connector
        &#34;&#34;&#34;

        resp = self.http.get(
            path=f&#34;/connectors/{name}&#34;,
        )

        return Connector(
            name=resp.get(&#34;name&#34;),
            description=resp.get(&#34;description&#34;),
            config=resp.get(&#34;config&#34;),
            id=resp.get(&#34;connector_id&#34;),
        )

    def create_connector(self, connector: Connector):
        &#34;&#34;&#34;
        Create a connector
        :param connector: The connector to create
        &#34;&#34;&#34;
        body = {
            &#34;description&#34;: connector.description or &#34;&#34;,
            &#34;config&#34;: connector.config
        }

        resp = self.http.put(
            path=f&#34;/connectors/{connector.name}&#34;,
            body=body,
        )

        connector.id = resp.get(&#34;connector_id&#34;)

    def delete_connector(self, name: str):
        &#34;&#34;&#34;
        Deletes a connector by name
        :param name: The name of the connector
        &#34;&#34;&#34;
        self.http.delete(
            path=f&#34;/connectors/{name}&#34;,
        )

    @staticmethod
    def __pipeline_from_dict(pipeline: dict) -&gt; Pipeline:
        attached_connectors = pipeline.get(&#34;attached_connectors&#34;)
        descriptor = pipeline.get(&#34;descriptor&#34;)
        return Pipeline(
            name=descriptor.get(&#34;name&#34;),
            program_name=descriptor.get(&#34;program_name&#34;),
            version=descriptor.get(&#34;version&#34;),
            description=descriptor.get(&#34;description&#34;),
            id=descriptor.get(&#34;id&#34;),
            config=descriptor.get(&#34;config&#34;),
            state=pipeline.get(&#34;state&#34;),
            attached_connectors=[
                AttachedConnector(
                    connector_name=con.get(&#34;connector_name&#34;),
                    is_input=con.get(&#34;is_input&#34;),
                    relation_name=con.get(&#34;relation_name&#34;),
                    name=con.get(&#34;name&#34;),
                )
                for con in attached_connectors
            ] if attached_connectors else []
        )

    def pipelines(self) -&gt; list[Pipeline]:
        &#34;&#34;&#34;
        Get all pipelines
        &#34;&#34;&#34;

        resp = self.http.get(
            path=&#34;/pipelines&#34;,
        )

        return [self.__pipeline_from_dict(pipeline) for pipeline in resp]

    def get_pipeline(self, name: str) -&gt; Pipeline:
        &#34;&#34;&#34;
        Get a pipeline by name
        &#34;&#34;&#34;

        resp = self.http.get(
            path=f&#34;/pipelines/{name}&#34;,
        )

        return self.__pipeline_from_dict(resp)

    def create_pipeline(self, pipeline: Pipeline):
        &#34;&#34;&#34;
        Create a pipeline
        &#34;&#34;&#34;

        body = {
            &#34;config&#34;: pipeline.config,
            &#34;description&#34;: pipeline.description or &#34;&#34;,
            &#34;connectors&#34;: pipeline.attached_connectors,
            &#34;program_name&#34;: pipeline.program_name,
        }

        resp = self.http.put(
            path=f&#34;/pipelines/{pipeline.name}&#34;,
            body=body,
        )

        pipeline.id = resp.get(&#34;pipeline_id&#34;)

    def get_pipeline_config(self, name: str) -&gt; dict:
        &#34;&#34;&#34;
        Get the configuration of a pipeline by name
        &#34;&#34;&#34;

        resp = self.http.get(
            path=f&#34;/pipelines/{name}/config&#34;,
        )

        return resp

    def validate_pipeline(self, name: str) -&gt; bool:
        &#34;&#34;&#34;
        Validate a pipeline.
        Checks whether the pipeline is configured correctly.
        This includes checking whether the pipeline references a valid compiled program,
        whether the connectors reference valid tables/views in the program, and more.
        &#34;&#34;&#34;

        resp = self.http.get(
            path=f&#34;/pipelines/{name}/validate&#34;,
        )

        return &#34;success&#34; in resp

    def delete_pipeline(self, name: str):
        &#34;&#34;&#34;
        Deletes a pipeline by name
        :param name: The name of the pipeline
        &#34;&#34;&#34;
        resp = self.http.delete(
            path=f&#34;/pipelines/{name}&#34;,
        )

    def get_pipeline_stats(self, name: str) -&gt; dict:
        &#34;&#34;&#34;
        Get the pipeline metrics and performance counters
        &#34;&#34;&#34;

        resp = self.http.get(
            path=f&#34;/pipelines/{name}/stats&#34;,
        )

        return resp

    def start_pipeline(self, pipeline_name: str):
        &#34;&#34;&#34;
        Start a pipeline
        :param pipeline_name: The name of the pipeline to start
        &#34;&#34;&#34;
        self.http.post(
            path=f&#34;/pipelines/{pipeline_name}/start&#34;,
        )

        while True:
            status = self.get_pipeline(pipeline_name).state.get(&#34;current_status&#34;)

            if status == &#34;Running&#34;:
                break
            elif status == &#34;Failed&#34;:
                raise RuntimeError(f&#34;Failed to start pipeline&#34;)

            logging.debug(&#34;still starting %s, waiting for 100 more milliseconds&#34;, pipeline_name)
            time.sleep(0.1)

    def pause_pipeline(self, pipeline_name: str):
        &#34;&#34;&#34;
        Stop a pipeline
        :param pipeline_name: The name of the pipeline to stop
        &#34;&#34;&#34;
        self.http.post(
            path=f&#34;/pipelines/{pipeline_name}/pause&#34;,
        )

        while True:
            status = self.get_pipeline(pipeline_name).state.get(&#34;current_status&#34;)

            if status == &#34;Paused&#34;:
                break
            elif status == &#34;Failed&#34;:
                raise RuntimeError(f&#34;Failed to pause pipeline&#34;)

            logging.debug(&#34;still pausing %s, waiting for 100 more milliseconds&#34;, pipeline_name)
            time.sleep(0.1)

    def shutdown_pipeline(self, pipeline_name: str):
        &#34;&#34;&#34;
        Shutdown a pipeline
        :param pipeline_name: The name of the pipeline to shutdown
        &#34;&#34;&#34;
        self.http.post(
            path=f&#34;/pipelines/{pipeline_name}/shutdown&#34;,
        )

        while True:
            status = self.get_pipeline(pipeline_name).state.get(&#34;current_status&#34;)

            if status == &#34;Shutdown&#34;:
                break
            elif status == &#34;Failed&#34;:
                raise RuntimeError(f&#34;Failed to shutdown pipeline&#34;)

            logging.debug(&#34;still shutting down %s, waiting for 100 more milliseconds&#34;, pipeline_name)
            time.sleep(0.1)

    # TODO: better name for this method
    def push_to_pipeline(
            self,
            pipeline_name: str,
            table_name: str,
            format: str,
            data: list[list | str | dict],
            array: bool = False,
            force: bool = False,
            update_format: str = &#34;raw&#34;,
    ):
        &#34;&#34;&#34;
        Insert data into a pipeline
        :param pipeline_name: The name of the pipeline
        :param table_name: The name of the table
        :param format: The format of the data, either &#34;json&#34; or &#34;csv&#34;
        :param array: Set True if updates in this stream are packed into JSON arrays, used in conjunction with the
            &#34;json&#34; format
        :param force: If True, the data will be inserted even if the pipeline is paused
        :param update_format: JSON data change event format, used in conjunction with the &#34;json&#34; format,
        the default value is &#34;insert_delete&#34;, other supported formats: &#34;weighted&#34;, &#34;debezium&#34;, &#34;snowflake&#34;, &#34;raw&#34;
        :param data: The data to insert
        &#34;&#34;&#34;

        if format not in [&#34;json&#34;, &#34;csv&#34;]:
            raise ValueError(&#34;format must be either &#39;json&#39; or &#39;csv&#39;&#34;)

        if update_format not in [&#34;insert_delete&#34;, &#34;weighted&#34;, &#34;debezium&#34;, &#34;snowflake&#34;, &#34;raw&#34;]:
            raise ValueError(&#34;update_format must be one of &#39;insert_delete&#39;, &#39;weighted&#39;, &#39;debezium&#39;, &#39;snowflake&#39;, &#39;raw&#39;&#34;)

        # python sends `True` which isn&#39;t accepted by the backend
        array = &#34;true&#34; if array else &#34;false&#34;
        force = &#34;true&#34; if force else &#34;false&#34;

        params = {
            &#34;force&#34;: force,
            &#34;format&#34;: format,
        }

        if format == &#34;json&#34;:
            params[&#34;array&#34;] = array
            params[&#34;update_format&#34;] = update_format

        content_type = &#34;application/json&#34;

        self.start_pipeline(pipeline_name)

        if format == &#34;csv&#34;:
            content_type = &#34;text/csv&#34;
            data = bytes(str(data), &#34;utf-8&#34;)

        self.http.post(
            path=f&#34;/pipelines/{pipeline_name}/ingress/{table_name}&#34;,
            params=params,
            content_type=content_type,
            body=data,
        )</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="python.feldera.client.Client.compile_program"><code class="name flex">
<span>def <span class="ident">compile_program</span></span>(<span>self, program: feldera.program.Program)</span>
</code></dt>
<dd>
<div class="desc"><p>Compiles a SQL program
:param program: The program to compile</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compile_program(self, program: Program):
    &#34;&#34;&#34;
    Compiles a SQL program
    :param program: The program to compile
    &#34;&#34;&#34;
    body = {
        &#34;code&#34;: program.program,
        &#34;description&#34;: program.description or &#34;&#34;,
    }

    resp = self.http.put(
        path=f&#34;/programs/{program.name}&#34;,
        body=body,
    )
    program.id = resp.get(&#34;program_id&#34;)
    program.version = resp.get(&#34;version&#34;)

    while True:
        status = self.get_program(program.name).status

        if status == &#34;Success&#34;:
            break
        elif status != &#34;Pending&#34; and status != &#34;CompilingRust&#34; and status != &#34;CompilingSql&#34;:
            raise RuntimeError(f&#34;Failed program compilation with status {status}&#34;)

        logging.debug(&#34;still compiling %s, waiting for 5 more seconds&#34;, program.name)
        time.sleep(5)</code></pre>
</details>
</dd>
<dt id="python.feldera.client.Client.connectors"><code class="name flex">
<span>def <span class="ident">connectors</span></span>(<span>self) ‑> list[feldera.connector.Connector]</span>
</code></dt>
<dd>
<div class="desc"><p>Get all connectors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def connectors(self) -&gt; list[Connector]:
    &#34;&#34;&#34;
    Get all connectors
    &#34;&#34;&#34;

    resp = self.http.get(
        path=&#34;/connectors&#34;,
    )

    return [
        Connector(
            name=connector.get(&#34;name&#34;),
            description=connector.get(&#34;description&#34;),
            config=connector.get(&#34;config&#34;),
            id=connector.get(&#34;connector_id&#34;),
        ) for connector in resp
    ]</code></pre>
</details>
</dd>
<dt id="python.feldera.client.Client.create_connector"><code class="name flex">
<span>def <span class="ident">create_connector</span></span>(<span>self, connector: feldera.connector.Connector)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a connector
:param connector: The connector to create</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_connector(self, connector: Connector):
    &#34;&#34;&#34;
    Create a connector
    :param connector: The connector to create
    &#34;&#34;&#34;
    body = {
        &#34;description&#34;: connector.description or &#34;&#34;,
        &#34;config&#34;: connector.config
    }

    resp = self.http.put(
        path=f&#34;/connectors/{connector.name}&#34;,
        body=body,
    )

    connector.id = resp.get(&#34;connector_id&#34;)</code></pre>
</details>
</dd>
<dt id="python.feldera.client.Client.create_pipeline"><code class="name flex">
<span>def <span class="ident">create_pipeline</span></span>(<span>self, pipeline: feldera.pipeline.Pipeline)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a pipeline</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_pipeline(self, pipeline: Pipeline):
    &#34;&#34;&#34;
    Create a pipeline
    &#34;&#34;&#34;

    body = {
        &#34;config&#34;: pipeline.config,
        &#34;description&#34;: pipeline.description or &#34;&#34;,
        &#34;connectors&#34;: pipeline.attached_connectors,
        &#34;program_name&#34;: pipeline.program_name,
    }

    resp = self.http.put(
        path=f&#34;/pipelines/{pipeline.name}&#34;,
        body=body,
    )

    pipeline.id = resp.get(&#34;pipeline_id&#34;)</code></pre>
</details>
</dd>
<dt id="python.feldera.client.Client.delete_connector"><code class="name flex">
<span>def <span class="ident">delete_connector</span></span>(<span>self, name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes a connector by name
:param name: The name of the connector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_connector(self, name: str):
    &#34;&#34;&#34;
    Deletes a connector by name
    :param name: The name of the connector
    &#34;&#34;&#34;
    self.http.delete(
        path=f&#34;/connectors/{name}&#34;,
    )</code></pre>
</details>
</dd>
<dt id="python.feldera.client.Client.delete_pipeline"><code class="name flex">
<span>def <span class="ident">delete_pipeline</span></span>(<span>self, name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes a pipeline by name
:param name: The name of the pipeline</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_pipeline(self, name: str):
    &#34;&#34;&#34;
    Deletes a pipeline by name
    :param name: The name of the pipeline
    &#34;&#34;&#34;
    resp = self.http.delete(
        path=f&#34;/pipelines/{name}&#34;,
    )</code></pre>
</details>
</dd>
<dt id="python.feldera.client.Client.delete_program"><code class="name flex">
<span>def <span class="ident">delete_program</span></span>(<span>self, name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Deletes a program by name
:param name: The name of the program</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def delete_program(self, name: str):
    &#34;&#34;&#34;
    Deletes a program by name
    :param name: The name of the program
    &#34;&#34;&#34;

    self.http.delete(
        path=f&#34;/programs/{name}&#34;,
    )</code></pre>
</details>
</dd>
<dt id="python.feldera.client.Client.get_connector"><code class="name flex">
<span>def <span class="ident">get_connector</span></span>(<span>self, name: str) ‑> feldera.connector.Connector</span>
</code></dt>
<dd>
<div class="desc"><p>Get a connector by name
:param name: The name of the connector</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_connector(self, name: str) -&gt; Connector:
    &#34;&#34;&#34;
    Get a connector by name
    :param name: The name of the connector
    &#34;&#34;&#34;

    resp = self.http.get(
        path=f&#34;/connectors/{name}&#34;,
    )

    return Connector(
        name=resp.get(&#34;name&#34;),
        description=resp.get(&#34;description&#34;),
        config=resp.get(&#34;config&#34;),
        id=resp.get(&#34;connector_id&#34;),
    )</code></pre>
</details>
</dd>
<dt id="python.feldera.client.Client.get_pipeline"><code class="name flex">
<span>def <span class="ident">get_pipeline</span></span>(<span>self, name: str) ‑> feldera.pipeline.Pipeline</span>
</code></dt>
<dd>
<div class="desc"><p>Get a pipeline by name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pipeline(self, name: str) -&gt; Pipeline:
    &#34;&#34;&#34;
    Get a pipeline by name
    &#34;&#34;&#34;

    resp = self.http.get(
        path=f&#34;/pipelines/{name}&#34;,
    )

    return self.__pipeline_from_dict(resp)</code></pre>
</details>
</dd>
<dt id="python.feldera.client.Client.get_pipeline_config"><code class="name flex">
<span>def <span class="ident">get_pipeline_config</span></span>(<span>self, name: str) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Get the configuration of a pipeline by name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pipeline_config(self, name: str) -&gt; dict:
    &#34;&#34;&#34;
    Get the configuration of a pipeline by name
    &#34;&#34;&#34;

    resp = self.http.get(
        path=f&#34;/pipelines/{name}/config&#34;,
    )

    return resp</code></pre>
</details>
</dd>
<dt id="python.feldera.client.Client.get_pipeline_stats"><code class="name flex">
<span>def <span class="ident">get_pipeline_stats</span></span>(<span>self, name: str) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Get the pipeline metrics and performance counters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_pipeline_stats(self, name: str) -&gt; dict:
    &#34;&#34;&#34;
    Get the pipeline metrics and performance counters
    &#34;&#34;&#34;

    resp = self.http.get(
        path=f&#34;/pipelines/{name}/stats&#34;,
    )

    return resp</code></pre>
</details>
</dd>
<dt id="python.feldera.client.Client.get_program"><code class="name flex">
<span>def <span class="ident">get_program</span></span>(<span>self, name: str, with_code: bool = False) ‑> feldera.program.Program</span>
</code></dt>
<dd>
<div class="desc"><p>Get a program by name
:param name: The name of the program
:param with_code: If True, the program code will be included in the response</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_program(self, name: str, with_code: bool = False) -&gt; Program:
    &#34;&#34;&#34;
    Get a program by name
    :param name: The name of the program
    :param with_code: If True, the program code will be included in the response
    &#34;&#34;&#34;
    resp = self.http.get(
        path=f&#34;/programs/{name}&#34;,
        params={
            &#34;with_code&#34;: with_code,
        }
    )

    return Program(
        name=resp.get(&#34;name&#34;),
        program=resp.get(&#34;code&#34;),
        description=resp.get(&#34;description&#34;),
        status=resp.get(&#34;status&#34;),
        version=resp.get(&#34;version&#34;),
    )</code></pre>
</details>
</dd>
<dt id="python.feldera.client.Client.pause_pipeline"><code class="name flex">
<span>def <span class="ident">pause_pipeline</span></span>(<span>self, pipeline_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Stop a pipeline
:param pipeline_name: The name of the pipeline to stop</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pause_pipeline(self, pipeline_name: str):
    &#34;&#34;&#34;
    Stop a pipeline
    :param pipeline_name: The name of the pipeline to stop
    &#34;&#34;&#34;
    self.http.post(
        path=f&#34;/pipelines/{pipeline_name}/pause&#34;,
    )

    while True:
        status = self.get_pipeline(pipeline_name).state.get(&#34;current_status&#34;)

        if status == &#34;Paused&#34;:
            break
        elif status == &#34;Failed&#34;:
            raise RuntimeError(f&#34;Failed to pause pipeline&#34;)

        logging.debug(&#34;still pausing %s, waiting for 100 more milliseconds&#34;, pipeline_name)
        time.sleep(0.1)</code></pre>
</details>
</dd>
<dt id="python.feldera.client.Client.pipelines"><code class="name flex">
<span>def <span class="ident">pipelines</span></span>(<span>self) ‑> list[feldera.pipeline.Pipeline]</span>
</code></dt>
<dd>
<div class="desc"><p>Get all pipelines</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pipelines(self) -&gt; list[Pipeline]:
    &#34;&#34;&#34;
    Get all pipelines
    &#34;&#34;&#34;

    resp = self.http.get(
        path=&#34;/pipelines&#34;,
    )

    return [self.__pipeline_from_dict(pipeline) for pipeline in resp]</code></pre>
</details>
</dd>
<dt id="python.feldera.client.Client.programs"><code class="name flex">
<span>def <span class="ident">programs</span></span>(<span>self) ‑> list[feldera.program.Program]</span>
</code></dt>
<dd>
<div class="desc"><p>Get all programs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def programs(self) -&gt; list[Program]:
    &#34;&#34;&#34;
    Get all programs
    &#34;&#34;&#34;
    resp = self.http.get(
        path=&#34;/programs&#34;,
    )

    return [
        Program(
            name=program.get(&#34;name&#34;),
            program=program.get(&#34;code&#34;),
            description=program.get(&#34;description&#34;),
        ) for program in resp
    ]</code></pre>
</details>
</dd>
<dt id="python.feldera.client.Client.push_to_pipeline"><code class="name flex">
<span>def <span class="ident">push_to_pipeline</span></span>(<span>self, pipeline_name: str, table_name: str, format: str, data: list[list | str | dict], array: bool = False, force: bool = False, update_format: str = 'raw')</span>
</code></dt>
<dd>
<div class="desc"><p>Insert data into a pipeline
:param pipeline_name: The name of the pipeline
:param table_name: The name of the table
:param format: The format of the data, either "json" or "csv"
:param array: Set True if updates in this stream are packed into JSON arrays, used in conjunction with the
"json" format
:param force: If True, the data will be inserted even if the pipeline is paused
:param update_format: JSON data change event format, used in conjunction with the "json" format,
the default value is "insert_delete", other supported formats: "weighted", "debezium", "snowflake", "raw"
:param data: The data to insert</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push_to_pipeline(
        self,
        pipeline_name: str,
        table_name: str,
        format: str,
        data: list[list | str | dict],
        array: bool = False,
        force: bool = False,
        update_format: str = &#34;raw&#34;,
):
    &#34;&#34;&#34;
    Insert data into a pipeline
    :param pipeline_name: The name of the pipeline
    :param table_name: The name of the table
    :param format: The format of the data, either &#34;json&#34; or &#34;csv&#34;
    :param array: Set True if updates in this stream are packed into JSON arrays, used in conjunction with the
        &#34;json&#34; format
    :param force: If True, the data will be inserted even if the pipeline is paused
    :param update_format: JSON data change event format, used in conjunction with the &#34;json&#34; format,
    the default value is &#34;insert_delete&#34;, other supported formats: &#34;weighted&#34;, &#34;debezium&#34;, &#34;snowflake&#34;, &#34;raw&#34;
    :param data: The data to insert
    &#34;&#34;&#34;

    if format not in [&#34;json&#34;, &#34;csv&#34;]:
        raise ValueError(&#34;format must be either &#39;json&#39; or &#39;csv&#39;&#34;)

    if update_format not in [&#34;insert_delete&#34;, &#34;weighted&#34;, &#34;debezium&#34;, &#34;snowflake&#34;, &#34;raw&#34;]:
        raise ValueError(&#34;update_format must be one of &#39;insert_delete&#39;, &#39;weighted&#39;, &#39;debezium&#39;, &#39;snowflake&#39;, &#39;raw&#39;&#34;)

    # python sends `True` which isn&#39;t accepted by the backend
    array = &#34;true&#34; if array else &#34;false&#34;
    force = &#34;true&#34; if force else &#34;false&#34;

    params = {
        &#34;force&#34;: force,
        &#34;format&#34;: format,
    }

    if format == &#34;json&#34;:
        params[&#34;array&#34;] = array
        params[&#34;update_format&#34;] = update_format

    content_type = &#34;application/json&#34;

    self.start_pipeline(pipeline_name)

    if format == &#34;csv&#34;:
        content_type = &#34;text/csv&#34;
        data = bytes(str(data), &#34;utf-8&#34;)

    self.http.post(
        path=f&#34;/pipelines/{pipeline_name}/ingress/{table_name}&#34;,
        params=params,
        content_type=content_type,
        body=data,
    )</code></pre>
</details>
</dd>
<dt id="python.feldera.client.Client.shutdown_pipeline"><code class="name flex">
<span>def <span class="ident">shutdown_pipeline</span></span>(<span>self, pipeline_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Shutdown a pipeline
:param pipeline_name: The name of the pipeline to shutdown</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shutdown_pipeline(self, pipeline_name: str):
    &#34;&#34;&#34;
    Shutdown a pipeline
    :param pipeline_name: The name of the pipeline to shutdown
    &#34;&#34;&#34;
    self.http.post(
        path=f&#34;/pipelines/{pipeline_name}/shutdown&#34;,
    )

    while True:
        status = self.get_pipeline(pipeline_name).state.get(&#34;current_status&#34;)

        if status == &#34;Shutdown&#34;:
            break
        elif status == &#34;Failed&#34;:
            raise RuntimeError(f&#34;Failed to shutdown pipeline&#34;)

        logging.debug(&#34;still shutting down %s, waiting for 100 more milliseconds&#34;, pipeline_name)
        time.sleep(0.1)</code></pre>
</details>
</dd>
<dt id="python.feldera.client.Client.start_pipeline"><code class="name flex">
<span>def <span class="ident">start_pipeline</span></span>(<span>self, pipeline_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Start a pipeline
:param pipeline_name: The name of the pipeline to start</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def start_pipeline(self, pipeline_name: str):
    &#34;&#34;&#34;
    Start a pipeline
    :param pipeline_name: The name of the pipeline to start
    &#34;&#34;&#34;
    self.http.post(
        path=f&#34;/pipelines/{pipeline_name}/start&#34;,
    )

    while True:
        status = self.get_pipeline(pipeline_name).state.get(&#34;current_status&#34;)

        if status == &#34;Running&#34;:
            break
        elif status == &#34;Failed&#34;:
            raise RuntimeError(f&#34;Failed to start pipeline&#34;)

        logging.debug(&#34;still starting %s, waiting for 100 more milliseconds&#34;, pipeline_name)
        time.sleep(0.1)</code></pre>
</details>
</dd>
<dt id="python.feldera.client.Client.validate_pipeline"><code class="name flex">
<span>def <span class="ident">validate_pipeline</span></span>(<span>self, name: str) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Validate a pipeline.
Checks whether the pipeline is configured correctly.
This includes checking whether the pipeline references a valid compiled program,
whether the connectors reference valid tables/views in the program, and more.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def validate_pipeline(self, name: str) -&gt; bool:
    &#34;&#34;&#34;
    Validate a pipeline.
    Checks whether the pipeline is configured correctly.
    This includes checking whether the pipeline references a valid compiled program,
    whether the connectors reference valid tables/views in the program, and more.
    &#34;&#34;&#34;

    resp = self.http.get(
        path=f&#34;/pipelines/{name}/validate&#34;,
    )

    return &#34;success&#34; in resp</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="python.feldera" href="index.html">python.feldera</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="python.feldera.client.Client" href="#python.feldera.client.Client">Client</a></code></h4>
<ul class="two-column">
<li><code><a title="python.feldera.client.Client.compile_program" href="#python.feldera.client.Client.compile_program">compile_program</a></code></li>
<li><code><a title="python.feldera.client.Client.connectors" href="#python.feldera.client.Client.connectors">connectors</a></code></li>
<li><code><a title="python.feldera.client.Client.create_connector" href="#python.feldera.client.Client.create_connector">create_connector</a></code></li>
<li><code><a title="python.feldera.client.Client.create_pipeline" href="#python.feldera.client.Client.create_pipeline">create_pipeline</a></code></li>
<li><code><a title="python.feldera.client.Client.delete_connector" href="#python.feldera.client.Client.delete_connector">delete_connector</a></code></li>
<li><code><a title="python.feldera.client.Client.delete_pipeline" href="#python.feldera.client.Client.delete_pipeline">delete_pipeline</a></code></li>
<li><code><a title="python.feldera.client.Client.delete_program" href="#python.feldera.client.Client.delete_program">delete_program</a></code></li>
<li><code><a title="python.feldera.client.Client.get_connector" href="#python.feldera.client.Client.get_connector">get_connector</a></code></li>
<li><code><a title="python.feldera.client.Client.get_pipeline" href="#python.feldera.client.Client.get_pipeline">get_pipeline</a></code></li>
<li><code><a title="python.feldera.client.Client.get_pipeline_config" href="#python.feldera.client.Client.get_pipeline_config">get_pipeline_config</a></code></li>
<li><code><a title="python.feldera.client.Client.get_pipeline_stats" href="#python.feldera.client.Client.get_pipeline_stats">get_pipeline_stats</a></code></li>
<li><code><a title="python.feldera.client.Client.get_program" href="#python.feldera.client.Client.get_program">get_program</a></code></li>
<li><code><a title="python.feldera.client.Client.pause_pipeline" href="#python.feldera.client.Client.pause_pipeline">pause_pipeline</a></code></li>
<li><code><a title="python.feldera.client.Client.pipelines" href="#python.feldera.client.Client.pipelines">pipelines</a></code></li>
<li><code><a title="python.feldera.client.Client.programs" href="#python.feldera.client.Client.programs">programs</a></code></li>
<li><code><a title="python.feldera.client.Client.push_to_pipeline" href="#python.feldera.client.Client.push_to_pipeline">push_to_pipeline</a></code></li>
<li><code><a title="python.feldera.client.Client.shutdown_pipeline" href="#python.feldera.client.Client.shutdown_pipeline">shutdown_pipeline</a></code></li>
<li><code><a title="python.feldera.client.Client.start_pipeline" href="#python.feldera.client.Client.start_pipeline">start_pipeline</a></code></li>
<li><code><a title="python.feldera.client.Client.validate_pipeline" href="#python.feldera.client.Client.validate_pipeline">validate_pipeline</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>