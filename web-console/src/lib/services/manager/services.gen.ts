// This file is auto-generated by @hey-api/openapi-ts

import { client, type Options } from '@hey-api/client-fetch'
import type {
  GetConfigAuthenticationError,
  GetConfigAuthenticationResponse,
  ListApiKeysError,
  ListApiKeysResponse,
  PostApiKeyData,
  PostApiKeyError,
  PostApiKeyResponse,
  GetApiKeyData,
  GetApiKeyError,
  GetApiKeyResponse,
  DeleteApiKeyData,
  DeleteApiKeyError,
  DeleteApiKeyResponse,
  GetHealthError,
  GetHealthResponse,
  GetConfigError,
  GetConfigResponse,
  GetConfigDemosError,
  GetConfigDemosResponse,
  GetMetricsError,
  GetMetricsResponse,
  ListPipelinesData,
  ListPipelinesError,
  ListPipelinesResponse,
  PostPipelineData,
  PostPipelineError,
  PostPipelineResponse,
  GetPipelineData,
  GetPipelineError,
  GetPipelineResponse,
  PutPipelineData,
  PutPipelineError,
  PutPipelineResponse,
  DeletePipelineData,
  DeletePipelineError,
  DeletePipelineResponse,
  PatchPipelineData,
  PatchPipelineError,
  PatchPipelineResponse,
  ActivatePipelineData,
  ActivatePipelineError,
  ActivatePipelineResponse,
  CheckpointPipelineData,
  CheckpointPipelineError,
  CheckpointPipelineResponse,
  SyncCheckpointData,
  SyncCheckpointError,
  SyncCheckpointResponse,
  GetCheckpointSyncStatusData,
  GetCheckpointSyncStatusError,
  GetCheckpointSyncStatusResponse,
  GetCheckpointStatusData,
  GetCheckpointStatusError,
  GetCheckpointStatusResponse,
  GetPipelineCircuitProfileData,
  GetPipelineCircuitProfileError,
  GetPipelineCircuitProfileResponse,
  PostPipelineClearData,
  PostPipelineClearError,
  PostPipelineClearResponse,
  CommitTransactionData,
  CommitTransactionError,
  CommitTransactionResponse,
  CompletionStatusData,
  CompletionStatusError,
  CompletionStatusResponse2,
  HttpOutputData,
  HttpOutputError,
  HttpOutputResponse,
  GetPipelineHeapProfileData,
  GetPipelineHeapProfileError,
  GetPipelineHeapProfileResponse,
  HttpInputData,
  HttpInputError,
  HttpInputResponse,
  GetPipelineLogsData,
  GetPipelineLogsError,
  GetPipelineLogsResponse,
  GetPipelineMetricsData,
  GetPipelineMetricsError,
  GetPipelineMetricsResponse,
  PostPipelinePauseData,
  PostPipelinePauseError,
  PostPipelinePauseResponse,
  PipelineAdhocSqlData,
  PipelineAdhocSqlError,
  PipelineAdhocSqlResponse,
  PostPipelineStartData,
  PostPipelineStartError,
  PostPipelineStartResponse,
  StartTransactionData,
  StartTransactionError,
  StartTransactionResponse2,
  GetPipelineStatsData,
  GetPipelineStatsError,
  GetPipelineStatsResponse,
  PostPipelineStopData,
  PostPipelineStopError,
  PostPipelineStopResponse,
  GetPipelineSupportBundleData,
  GetPipelineSupportBundleError,
  GetPipelineSupportBundleResponse,
  CompletionTokenData,
  CompletionTokenError,
  CompletionTokenResponse2,
  GetPipelineInputConnectorStatusData,
  GetPipelineInputConnectorStatusError,
  GetPipelineInputConnectorStatusResponse,
  PostPipelineInputConnectorActionData,
  PostPipelineInputConnectorActionError,
  PostPipelineInputConnectorActionResponse,
  GetPipelineTimeSeriesData,
  GetPipelineTimeSeriesError,
  GetPipelineTimeSeriesResponse,
  GetPipelineTimeSeriesStreamData,
  GetPipelineTimeSeriesStreamError,
  GetPipelineTimeSeriesStreamResponse,
  GetPipelineOutputConnectorStatusData,
  GetPipelineOutputConnectorStatusError,
  GetPipelineOutputConnectorStatusResponse
} from './types.gen'

/**
 * Retrieve authentication provider configuration.
 */
export const getConfigAuthentication = (options?: Options) => {
  return (options?.client ?? client).get<
    GetConfigAuthenticationResponse,
    GetConfigAuthenticationError
  >({
    ...options,
    url: '/config/authentication'
  })
}

/**
 * Retrieve the list of API keys.
 */
export const listApiKeys = (options?: Options) => {
  return (options?.client ?? client).get<ListApiKeysResponse, ListApiKeysError>({
    ...options,
    url: '/v0/api_keys'
  })
}

/**
 * Create a new API key.
 */
export const postApiKey = (options: Options<PostApiKeyData>) => {
  return (options?.client ?? client).post<PostApiKeyResponse, PostApiKeyError>({
    ...options,
    url: '/v0/api_keys'
  })
}

/**
 * Retrieve an API key.
 */
export const getApiKey = (options: Options<GetApiKeyData>) => {
  return (options?.client ?? client).get<GetApiKeyResponse, GetApiKeyError>({
    ...options,
    url: '/v0/api_keys/{api_key_name}'
  })
}

/**
 * Delete an API key.
 */
export const deleteApiKey = (options: Options<DeleteApiKeyData>) => {
  return (options?.client ?? client).delete<DeleteApiKeyResponse, DeleteApiKeyError>({
    ...options,
    url: '/v0/api_keys/{api_key_name}'
  })
}

export const getHealth = (options?: Options) => {
  return (options?.client ?? client).get<GetHealthResponse, GetHealthError>({
    ...options,
    url: '/v0/cluster_healthz'
  })
}

/**
 * Retrieve general configuration.
 */
export const getConfig = (options?: Options) => {
  return (options?.client ?? client).get<GetConfigResponse, GetConfigError>({
    ...options,
    url: '/v0/config'
  })
}

/**
 * Retrieve the list of demos.
 */
export const getConfigDemos = (options?: Options) => {
  return (options?.client ?? client).get<GetConfigDemosResponse, GetConfigDemosError>({
    ...options,
    url: '/v0/config/demos'
  })
}

/**
 * Retrieve the metrics of all running pipelines belonging to this tenant.
 * The metrics are collected by making individual HTTP requests to `/metrics`
 * endpoint of each pipeline, of which only successful responses are included
 * in the returned list.
 */
export const getMetrics = (options?: Options) => {
  return (options?.client ?? client).get<GetMetricsResponse, GetMetricsError>({
    ...options,
    url: '/v0/metrics'
  })
}

/**
 * Retrieve the list of pipelines.
 * Configure which fields are included using the `selector` query parameter.
 */
export const listPipelines = (options?: Options<ListPipelinesData>) => {
  return (options?.client ?? client).get<ListPipelinesResponse, ListPipelinesError>({
    ...options,
    url: '/v0/pipelines'
  })
}

/**
 * Create a new pipeline.
 */
export const postPipeline = (options: Options<PostPipelineData>) => {
  return (options?.client ?? client).post<PostPipelineResponse, PostPipelineError>({
    ...options,
    url: '/v0/pipelines'
  })
}

/**
 * Retrieve a pipeline.
 * Configure which fields are included using the `selector` query parameter.
 */
export const getPipeline = (options: Options<GetPipelineData>) => {
  return (options?.client ?? client).get<GetPipelineResponse, GetPipelineError>({
    ...options,
    url: '/v0/pipelines/{pipeline_name}'
  })
}

/**
 * Fully update a pipeline if it already exists, otherwise create a new pipeline.
 */
export const putPipeline = (options: Options<PutPipelineData>) => {
  return (options?.client ?? client).put<PutPipelineResponse, PutPipelineError>({
    ...options,
    url: '/v0/pipelines/{pipeline_name}'
  })
}

/**
 * Delete a pipeline.
 */
export const deletePipeline = (options: Options<DeletePipelineData>) => {
  return (options?.client ?? client).delete<DeletePipelineResponse, DeletePipelineError>({
    ...options,
    url: '/v0/pipelines/{pipeline_name}'
  })
}

/**
 * Partially update a pipeline.
 */
export const patchPipeline = (options: Options<PatchPipelineData>) => {
  return (options?.client ?? client).patch<PatchPipelineResponse, PatchPipelineError>({
    ...options,
    url: '/v0/pipelines/{pipeline_name}'
  })
}

/**
 * Activates the pipeline if it is currently in standby mode.
 * This endpoint is only applicable when the pipeline is configured to start
 * from object store and launched in standby mode (`sync.standby: true`).
 */
export const activatePipeline = (options: Options<ActivatePipelineData>) => {
  return (options?.client ?? client).post<ActivatePipelineResponse, ActivatePipelineError>({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/activate'
  })
}

/**
 * Initiates checkpoint for a running or paused pipeline.
 * Returns a checkpoint sequence number that can be used with `/checkpoint_status` to
 * determine when the checkpoint has completed.
 */
export const checkpointPipeline = (options: Options<CheckpointPipelineData>) => {
  return (options?.client ?? client).post<CheckpointPipelineResponse, CheckpointPipelineError>({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/checkpoint'
  })
}

/**
 * Syncs latest checkpoints to the object store configured in pipeline config.
 */
export const syncCheckpoint = (options: Options<SyncCheckpointData>) => {
  return (options?.client ?? client).post<SyncCheckpointResponse, SyncCheckpointError>({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/checkpoint/sync'
  })
}

/**
 * Retrieve status of checkpoint sync activity in a pipeline.
 */
export const getCheckpointSyncStatus = (options: Options<GetCheckpointSyncStatusData>) => {
  return (options?.client ?? client).get<
    GetCheckpointSyncStatusResponse,
    GetCheckpointSyncStatusError
  >({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/checkpoint/sync_status'
  })
}

/**
 * Retrieve status of checkpoint activity in a pipeline.
 */
export const getCheckpointStatus = (options: Options<GetCheckpointStatusData>) => {
  return (options?.client ?? client).get<GetCheckpointStatusResponse, GetCheckpointStatusError>({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/checkpoint_status'
  })
}

/**
 * Retrieve the circuit performance profile of a running or paused pipeline.
 */
export const getPipelineCircuitProfile = (options: Options<GetPipelineCircuitProfileData>) => {
  return (options?.client ?? client).get<
    GetPipelineCircuitProfileResponse,
    GetPipelineCircuitProfileError
  >({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/circuit_profile'
  })
}

/**
 * Clears the pipeline storage asynchronously.
 * IMPORTANT: Clearing means disassociating the storage from the pipeline.
 * Depending on the storage type this can include its deletion.
 *
 * It sets the storage state to `Clearing`, after which the clearing process is
 * performed asynchronously. Progress should be monitored by polling the pipeline
 * using the `GET` endpoints. An `/clear` cannot be cancelled.
 */
export const postPipelineClear = (options: Options<PostPipelineClearData>) => {
  return (options?.client ?? client).post<PostPipelineClearResponse, PostPipelineClearError>({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/clear'
  })
}

/**
 * Commit the current transaction.
 */
export const commitTransaction = (options: Options<CommitTransactionData>) => {
  return (options?.client ?? client).post<CommitTransactionResponse, CommitTransactionError>({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/commit_transaction'
  })
}

/**
 * Check the status of a completion token returned by the `/ingress` or `/completion_token`
 * endpoint.
 */
export const completionStatus = (options: Options<CompletionStatusData>) => {
  return (options?.client ?? client).get<CompletionStatusResponse2, CompletionStatusError>({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/completion_status'
  })
}

/**
 * Subscribe to a stream of updates from a SQL view or table.
 * The pipeline responds with a continuous stream of changes to the specified
 * table or view, encoded using the format specified in the `?format=`
 * parameter. Updates are split into `Chunk`s.
 *
 * The pipeline continues sending updates until the client closes the
 * connection or the pipeline is stopped.
 */
export const httpOutput = (options: Options<HttpOutputData>) => {
  return (options?.client ?? client).post<HttpOutputResponse, HttpOutputError>({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/egress/{table_name}'
  })
}

/**
 * Retrieve the heap profile of a running or paused pipeline.
 */
export const getPipelineHeapProfile = (options: Options<GetPipelineHeapProfileData>) => {
  return (options?.client ?? client).get<
    GetPipelineHeapProfileResponse,
    GetPipelineHeapProfileError
  >({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/heap_profile'
  })
}

/**
 * Push data to a SQL table.
 * The client sends data encoded using the format specified in the `?format=`
 * parameter as a body of the request.  The contents of the data must match
 * the SQL table schema specified in `table_name`
 *
 * The pipeline ingests data as it arrives without waiting for the end of
 * the request.  Successful HTTP response indicates that all data has been
 * ingested successfully.
 *
 * On success, returns a completion token that can be passed to the
 * '/completion_status' endpoint to check whether the pipeline has fully
 * processed the data.
 */
export const httpInput = (options: Options<HttpInputData>) => {
  return (options?.client ?? client).post<HttpInputResponse, HttpInputError>({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/ingress/{table_name}'
  })
}

/**
 * Retrieve logs of a pipeline as a stream.
 * The logs stream catches up to the extent of the internally configured per-pipeline
 * circular logs buffer (limited to a certain byte size and number of lines, whichever
 * is reached first). After the catch-up, new lines are pushed whenever they become
 * available.
 *
 * It is possible for the logs stream to end prematurely due to the API server temporarily losing
 * connection to the runner. In this case, it is needed to issue again a new request to this
 * endpoint.
 *
 * The logs stream will end when the pipeline is deleted, or if the runner restarts. Note that in
 * both cases the logs will be cleared.
 */
export const getPipelineLogs = (options: Options<GetPipelineLogsData>) => {
  return (options?.client ?? client).get<GetPipelineLogsResponse, GetPipelineLogsError>({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/logs'
  })
}

/**
 * Retrieve circuit metrics of a running or paused pipeline.
 */
export const getPipelineMetrics = (options: Options<GetPipelineMetricsData>) => {
  return (options?.client ?? client).get<GetPipelineMetricsResponse, GetPipelineMetricsError>({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/metrics'
  })
}

/**
 * Pause the pipeline asynchronously by updating the desired state.
 * The endpoint returns immediately after setting the desired state to `Paused`.
 * The procedure to get to the desired state is performed asynchronously.
 * Progress should be monitored by polling the pipeline `GET` endpoints.
 *
 * Note the following:
 * - A stopped pipeline can be started through calling either `/start` or `/pause`
 * - Both starting as paused and pausing a pipeline is done by calling `/pause`
 * - A pipeline which is in the process of suspending or stopping cannot be paused
 */
export const postPipelinePause = (options: Options<PostPipelinePauseData>) => {
  return (options?.client ?? client).post<PostPipelinePauseResponse, PostPipelinePauseError>({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/pause'
  })
}

/**
 * Execute an ad-hoc SQL query in a running or paused pipeline.
 * The evaluation is not incremental.
 */
export const pipelineAdhocSql = (options: Options<PipelineAdhocSqlData>) => {
  return (options?.client ?? client).get<PipelineAdhocSqlResponse, PipelineAdhocSqlError>({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/query'
  })
}

/**
 * Start the pipeline asynchronously by updating the desired state.
 * The endpoint returns immediately after setting the desired state to `Running`.
 * The procedure to get to the desired state is performed asynchronously.
 * Progress should be monitored by polling the pipeline `GET` endpoints.
 *
 * Note the following:
 * - A stopped pipeline can be started through calling either `/start` or `/pause`
 * - Both starting as running and resuming a pipeline is done by calling `/start`
 * - A pipeline which is in the process of suspending or stopping cannot be started
 */
export const postPipelineStart = (options: Options<PostPipelineStartData>) => {
  return (options?.client ?? client).post<PostPipelineStartResponse, PostPipelineStartError>({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/start'
  })
}

/**
 * Start a transaction.
 */
export const startTransaction = (options: Options<StartTransactionData>) => {
  return (options?.client ?? client).post<StartTransactionResponse2, StartTransactionError>({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/start_transaction'
  })
}

/**
 * Retrieve statistics (e.g., performance counters) of a running or paused pipeline.
 */
export const getPipelineStats = (options: Options<GetPipelineStatsData>) => {
  return (options?.client ?? client).get<GetPipelineStatsResponse, GetPipelineStatsError>({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/stats'
  })
}

/**
 * Stop the pipeline asynchronously by updating the desired state.
 * There are two variants:
 * - `/stop?force=false` (default): the pipeline will first atomically checkpoint before
 * deprovisioning the compute resources. When resuming, the pipeline will start from this
 * - `/stop?force=true`: the compute resources will be immediately deprovisioned. When resuming,
 * it will pick up the latest checkpoint made by the periodic checkpointer or by a prior
 * `/checkpoint` call.
 *
 * The endpoint returns immediately after setting the desired state to `Suspended` for
 * `?force=false` or `Stopped` for `?force=true`. In the former case, once the pipeline has
 * successfully passes the `Suspending` state, the desired state will become `Stopped` as well.
 * The procedure to get to the desired state is performed asynchronously. Progress should be
 * monitored by polling the pipeline `GET` endpoints.
 *
 * Note the following:
 * - The suspending that is done with `/stop?force=false` is not guaranteed to succeed:
 * - If an error is returned during the suspension, the pipeline will be forcefully stopped with
 * that error set
 * - Otherwise, it will keep trying to suspend, in which case it is possible to cancel suspending
 * by calling `/stop?force=true`
 * - `/stop?force=true` cannot be cancelled: the pipeline must first reach `Stopped` before another
 * action can be done
 * - A pipeline which is in the process of suspending or stopping can only be forcefully stopped
 */
export const postPipelineStop = (options: Options<PostPipelineStopData>) => {
  return (options?.client ?? client).post<PostPipelineStopResponse, PostPipelineStopError>({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/stop'
  })
}

/**
 * Generate a support bundle for a pipeline.
 * This endpoint collects various diagnostic data from the pipeline including
 * circuit profile, heap profile, metrics, logs, stats, and connector statistics,
 * and packages them into a single ZIP file for support purposes.
 */
export const getPipelineSupportBundle = (options: Options<GetPipelineSupportBundleData>) => {
  return (options?.client ?? client).get<
    GetPipelineSupportBundleResponse,
    GetPipelineSupportBundleError
  >({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/support_bundle'
  })
}

/**
 * Generate a completion token for an input connector.
 * Returns a token that can be passed to the `/completion_status` endpoint
 * to check whether the pipeline has finished processing all inputs received from the
 * connector before the token was generated.
 */
export const completionToken = (options: Options<CompletionTokenData>) => {
  return (options?.client ?? client).get<CompletionTokenResponse2, CompletionTokenError>({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/tables/{table_name}/connectors/{connector_name}/completion_token'
  })
}

/**
 * Retrieve the status of an input connector.
 */
export const getPipelineInputConnectorStatus = (
  options: Options<GetPipelineInputConnectorStatusData>
) => {
  return (options?.client ?? client).get<
    GetPipelineInputConnectorStatusResponse,
    GetPipelineInputConnectorStatusError
  >({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/tables/{table_name}/connectors/{connector_name}/stats'
  })
}

/**
 * Start (resume) or pause the input connector.
 * The following values of the `action` argument are accepted: `start` and `pause`.
 *
 * Input connectors can be in either the `Running` or `Paused` state. By default,
 * connectors are initialized in the `Running` state when a pipeline is deployed.
 * In this state, the connector actively fetches data from its configured data
 * source and forwards it to the pipeline. If needed, a connector can be created
 * in the `Paused` state by setting its
 * [`paused`](https://docs.feldera.com/connectors/#generic-attributes) property
 * to `true`. When paused, the connector remains idle until reactivated using the
 * `start` command. Conversely, a connector in the `Running` state can be paused
 * at any time by issuing the `pause` command.
 *
 * The current connector state can be retrieved via the
 * `GET /v0/pipelines/{pipeline_name}/stats` endpoint.
 *
 * Note that only if both the pipeline *and* the connector state is `Running`,
 * is the input connector active.
 * ```text
 * Pipeline state    Connector state    Connector is active?
 * --------------    ---------------    --------------------
 * Paused            Paused             No
 * Paused            Running            No
 * Running           Paused             No
 * Running           Running            Yes
 * ```
 */
export const postPipelineInputConnectorAction = (
  options: Options<PostPipelineInputConnectorActionData>
) => {
  return (options?.client ?? client).post<
    PostPipelineInputConnectorActionResponse,
    PostPipelineInputConnectorActionError
  >({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/tables/{table_name}/connectors/{connector_name}/{action}'
  })
}

/**
 * Retrieve time series for statistics of a running or paused pipeline.
 */
export const getPipelineTimeSeries = (options: Options<GetPipelineTimeSeriesData>) => {
  return (options?.client ?? client).get<GetPipelineTimeSeriesResponse, GetPipelineTimeSeriesError>(
    {
      ...options,
      url: '/v0/pipelines/{pipeline_name}/time_series'
    }
  )
}

/**
 * Stream time series for statistics of a running or paused pipeline.
 * Returns a snapshot of all existing time series data followed by a continuous stream of
 * new time series data points as they become available. The response is in newline-delimited
 * JSON format (NDJSON) where each line is a JSON object representing a single time series
 * data point.
 */
export const getPipelineTimeSeriesStream = (options: Options<GetPipelineTimeSeriesStreamData>) => {
  return (options?.client ?? client).get<
    GetPipelineTimeSeriesStreamResponse,
    GetPipelineTimeSeriesStreamError
  >({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/time_series_stream'
  })
}

/**
 * Retrieve the status of an output connector.
 */
export const getPipelineOutputConnectorStatus = (
  options: Options<GetPipelineOutputConnectorStatusData>
) => {
  return (options?.client ?? client).get<
    GetPipelineOutputConnectorStatusResponse,
    GetPipelineOutputConnectorStatusError
  >({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/views/{view_name}/connectors/{connector_name}/stats'
  })
}
