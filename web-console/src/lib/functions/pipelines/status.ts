import type { PipelineStatus } from '$lib/services/pipelineManager'
import { P, match } from 'ts-pattern'

export const getPipelineStatusLabel = (status: PipelineStatus) => {
  return match(status)
    .with('Shutdown', () => 'Ready To Start')
    .with('Starting up', () => 'Starting up')
    .with('Initializing', () => 'Initializing')
    .with('Paused', () => 'Paused')
    .with('Running', () => 'Running')
    .with('Pausing', () => 'Pausing')
    .with('Resuming', () => 'Resuming')
    .with('ShuttingDown', () => 'Shutting Down')
    .with({ PipelineError: P.select() }, () => 'Pipeline Error')
    .with('Compiling SQL', () => 'Compiling SQL')
    .with('SQL compiled', () => 'SQL compiled')
    .with('Queued', () => 'Queued')
    .with('Compiling binary', () => 'Compiling Rust')
    .with('Unavailable', () => 'Unavailable')
    .with({ SqlError: P.select() }, () => 'Program Error')
    .with({ RustError: P.select() }, () => 'Program Error')
    .with({ SystemError: P.select() }, () => 'Program Error')
    .exhaustive()
}

export const getDeploymentStatusLabel = (status: PipelineStatus) => {
  return match(status)
    .with('Shutdown', () => '')
    .with('Starting up', () => 'Starting up')
    .with('Initializing', () => 'Initializing')
    .with('Paused', () => 'Paused')
    .with('Running', () => 'Running')
    .with('Pausing', () => 'Pausing')
    .with('Resuming', () => 'Resuming')
    .with('ShuttingDown', () => 'Shutting Down')
    .with({ PipelineError: P.select() }, () => 'Pipeline Error')
    .with('Compiling SQL', () => '')
    .with('SQL compiled', () => '')
    .with('Queued', () => '')
    .with('Compiling binary', () => '')
    .with('Unavailable', () => 'Unavailable')
    .with({ SqlError: P.select() }, () => '')
    .with({ RustError: P.select() }, () => '')
    .with({ SystemError: P.select() }, () => '')
    .exhaustive()
}

export const isPipelineIdle = (status: PipelineStatus) => {
  return match(status)
    .with('Shutdown', () => true)
    .with('Starting up', () => false)
    .with('Initializing', () => false)
    .with('Paused', () => false)
    .with('Running', () => false)
    .with('Pausing', () => false)
    .with('Resuming', () => false)
    .with('ShuttingDown', () => false)
    .with({ PipelineError: P.select() }, () => false)
    .with('Compiling SQL', () => true)
    .with('SQL compiled', () => true)
    .with('Queued', () => true)
    .with('Compiling binary', () => true)
    .with('Unavailable', () => false)
    .with({ SqlError: P.select() }, () => true)
    .with({ RustError: P.select() }, () => true)
    .with({ SystemError: P.select() }, () => true)
    .exhaustive()
}

export const isMetricsAvailable = (status: PipelineStatus) => {
  return match(status)
    .with('Shutdown', () => 'no' as const)
    .with('Starting up', () => 'no' as const)
    .with('Initializing', () => 'no' as const)
    .with('Paused', () => 'yes' as const)
    .with('Running', () => 'yes' as const)
    .with('Pausing', () => 'yes' as const)
    .with('Resuming', () => 'yes' as const)
    .with('ShuttingDown', () => 'no' as const)
    .with({ PipelineError: P.select() }, () => 'no' as const)
    .with('Compiling SQL', () => 'no' as const)
    .with('SQL compiled', () => 'no' as const)
    .with('Queued', () => 'no' as const)
    .with('Compiling binary', () => 'no' as const)
    .with('Unavailable', () => 'soon' as const)
    .with({ SqlError: P.select() }, () => 'no' as const)
    .with({ RustError: P.select() }, () => 'no' as const)
    .with({ SystemError: P.select() }, () => 'no' as const)
    .exhaustive()
}
