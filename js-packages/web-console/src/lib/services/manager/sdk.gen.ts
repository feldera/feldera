// This file is auto-generated by @hey-api/openapi-ts

import type { Client, Options as Options2, TDataShape } from './client'
import { client } from './client.gen'
import type {
  CheckpointPipelineData,
  CheckpointPipelineErrors,
  CheckpointPipelineResponses,
  CommitTransactionData,
  CommitTransactionErrors,
  CommitTransactionResponses,
  CompletionStatusData,
  CompletionStatusErrors,
  CompletionStatusResponses,
  CompletionTokenData,
  CompletionTokenErrors,
  CompletionTokenResponses,
  DeleteApiKeyData,
  DeleteApiKeyErrors,
  DeleteApiKeyResponses,
  DeletePipelineData,
  DeletePipelineErrors,
  DeletePipelineResponses,
  GetApiKeyData,
  GetApiKeyErrors,
  GetApiKeyResponses,
  GetCheckpointStatusData,
  GetCheckpointStatusErrors,
  GetCheckpointStatusResponses,
  GetCheckpointSyncStatusData,
  GetCheckpointSyncStatusErrors,
  GetCheckpointSyncStatusResponses,
  GetClusterEventData,
  GetClusterEventErrors,
  GetClusterEventResponses,
  GetClusterHealthData,
  GetClusterHealthErrors,
  GetClusterHealthResponses,
  GetConfigAuthenticationData,
  GetConfigAuthenticationErrors,
  GetConfigAuthenticationResponses,
  GetConfigData,
  GetConfigDemosData,
  GetConfigDemosErrors,
  GetConfigDemosResponses,
  GetConfigErrors,
  GetConfigResponses,
  GetConfigSessionData,
  GetConfigSessionErrors,
  GetConfigSessionResponses,
  GetMetricsData,
  GetMetricsResponses,
  GetPipelineCircuitJsonProfileData,
  GetPipelineCircuitJsonProfileErrors,
  GetPipelineCircuitJsonProfileResponses,
  GetPipelineCircuitProfileData,
  GetPipelineCircuitProfileErrors,
  GetPipelineCircuitProfileResponses,
  GetPipelineData,
  GetPipelineDataflowGraphData,
  GetPipelineDataflowGraphErrors,
  GetPipelineDataflowGraphResponses,
  GetPipelineErrors,
  GetPipelineHeapProfileData,
  GetPipelineHeapProfileErrors,
  GetPipelineHeapProfileResponses,
  GetPipelineInputConnectorStatusData,
  GetPipelineInputConnectorStatusErrors,
  GetPipelineInputConnectorStatusResponses,
  GetPipelineLogsData,
  GetPipelineLogsErrors,
  GetPipelineLogsResponses,
  GetPipelineMetricsData,
  GetPipelineMetricsErrors,
  GetPipelineMetricsResponses,
  GetPipelineOutputConnectorStatusData,
  GetPipelineOutputConnectorStatusErrors,
  GetPipelineOutputConnectorStatusResponses,
  GetPipelineResponses,
  GetPipelineSamplyProfileData,
  GetPipelineSamplyProfileErrors,
  GetPipelineSamplyProfileResponses,
  GetPipelineStatsData,
  GetPipelineStatsErrors,
  GetPipelineStatsResponses,
  GetPipelineSupportBundleData,
  GetPipelineSupportBundleErrors,
  GetPipelineSupportBundleResponses,
  GetPipelineTimeSeriesData,
  GetPipelineTimeSeriesErrors,
  GetPipelineTimeSeriesResponses,
  GetPipelineTimeSeriesStreamData,
  GetPipelineTimeSeriesStreamErrors,
  GetPipelineTimeSeriesStreamResponses,
  HttpInputData,
  HttpInputErrors,
  HttpInputResponses,
  HttpOutputData,
  HttpOutputErrors,
  HttpOutputResponses,
  ListApiKeysData,
  ListApiKeysErrors,
  ListApiKeysResponses,
  ListClusterEventsData,
  ListClusterEventsErrors,
  ListClusterEventsResponses,
  ListPipelinesData,
  ListPipelinesErrors,
  ListPipelinesResponses,
  PatchPipelineData,
  PatchPipelineErrors,
  PatchPipelineResponses,
  PipelineAdhocSqlData,
  PipelineAdhocSqlErrors,
  PipelineAdhocSqlResponses,
  PostApiKeyData,
  PostApiKeyErrors,
  PostApiKeyResponses,
  PostPipelineActivateData,
  PostPipelineActivateErrors,
  PostPipelineActivateResponses,
  PostPipelineApproveData,
  PostPipelineApproveErrors,
  PostPipelineApproveResponses,
  PostPipelineClearData,
  PostPipelineClearErrors,
  PostPipelineClearResponses,
  PostPipelineData,
  PostPipelineErrors,
  PostPipelineInputConnectorActionData,
  PostPipelineInputConnectorActionErrors,
  PostPipelineInputConnectorActionResponses,
  PostPipelinePauseData,
  PostPipelinePauseErrors,
  PostPipelinePauseResponses,
  PostPipelineRebalanceData,
  PostPipelineRebalanceErrors,
  PostPipelineRebalanceResponses,
  PostPipelineResponses,
  PostPipelineResumeData,
  PostPipelineResumeErrors,
  PostPipelineResumeResponses,
  PostPipelineStartData,
  PostPipelineStartErrors,
  PostPipelineStartResponses,
  PostPipelineStopData,
  PostPipelineStopErrors,
  PostPipelineStopResponses,
  PostPipelineTestingData,
  PostPipelineTestingErrors,
  PostPipelineTestingResponses,
  PostUpdateRuntimeData,
  PostUpdateRuntimeErrors,
  PostUpdateRuntimeResponses,
  PutPipelineData,
  PutPipelineErrors,
  PutPipelineResponses,
  StartSamplyProfileData,
  StartSamplyProfileErrors,
  StartSamplyProfileResponses,
  StartTransactionData,
  StartTransactionErrors,
  StartTransactionResponses,
  SyncCheckpointData,
  SyncCheckpointErrors,
  SyncCheckpointResponses
} from './types.gen'

export type Options<
  TData extends TDataShape = TDataShape,
  ThrowOnError extends boolean = boolean
> = Options2<TData, ThrowOnError> & {
  /**
   * You can provide a client instance returned by `createClient()` instead of
   * individual options. This might be also useful if you want to implement a
   * custom client.
   */
  client?: Client
  /**
   * You can pass arbitrary values through the `meta` object. This can be
   * used to access values that aren't defined as part of the SDK function.
   */
  meta?: Record<string, unknown>
}

/**
 * Get Auth Config
 *
 * Retrieve the authentication provider configuration.
 */
export const getConfigAuthentication = <ThrowOnError extends boolean = false>(
  options?: Options<GetConfigAuthenticationData, ThrowOnError>
) =>
  (options?.client ?? client).get<
    GetConfigAuthenticationResponses,
    GetConfigAuthenticationErrors,
    ThrowOnError
  >({ url: '/config/authentication', ...options })

/**
 * List API Keys
 *
 * Retrieve a list of your API keys.
 */
export const listApiKeys = <ThrowOnError extends boolean = false>(
  options?: Options<ListApiKeysData, ThrowOnError>
) =>
  (options?.client ?? client).get<ListApiKeysResponses, ListApiKeysErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/api_keys',
    ...options
  })

/**
 * Create API Key
 *
 * Create a new API key with the specified name. The generated API key
 * will be returned in the response and cannot be retrieved again later.
 */
export const postApiKey = <ThrowOnError extends boolean = false>(
  options: Options<PostApiKeyData, ThrowOnError>
) =>
  (options.client ?? client).post<PostApiKeyResponses, PostApiKeyErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/api_keys',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers
    }
  })

/**
 * Delete API Key
 *
 * Remove an API key by its name.
 */
export const deleteApiKey = <ThrowOnError extends boolean = false>(
  options: Options<DeleteApiKeyData, ThrowOnError>
) =>
  (options.client ?? client).delete<DeleteApiKeyResponses, DeleteApiKeyErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/api_keys/{api_key_name}',
    ...options
  })

/**
 * Get API Key
 *
 * Retrieve the metadata of a specific API key by its name.
 */
export const getApiKey = <ThrowOnError extends boolean = false>(
  options: Options<GetApiKeyData, ThrowOnError>
) =>
  (options.client ?? client).get<GetApiKeyResponses, GetApiKeyErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/api_keys/{api_key_name}',
    ...options
  })

/**
 * List Cluster Events
 *
 * Retrieve a list of retained cluster monitor events ordered from most recent to least recent.
 *
 * The returned events only have limited details, the full details can be retrieved using
 * the `GET /v0/cluster/events/<event-id>` endpoint.
 *
 * Cluster monitor events are collected at a periodic interval (every 10s), however only
 * every 10 minutes or if the overall health changes, does it get inserted into the database
 * (and thus, served by this endpoint). At most 1000 events are retained (newest first),
 * and events older than 72h are deleted. The latest event, if it already exists, is never
 * cleaned up.
 */
export const listClusterEvents = <ThrowOnError extends boolean = false>(
  options?: Options<ListClusterEventsData, ThrowOnError>
) =>
  (options?.client ?? client).get<
    ListClusterEventsResponses,
    ListClusterEventsErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/cluster/events',
    ...options
  })

/**
 * Get Cluster Event
 *
 * Get specific cluster monitor event.
 *
 * The identifiers of the events can be retrieved via `GET /v0/cluster/events`.
 * At most 1000 events are retained (newest first), and events older than 72h are deleted.
 * The latest event, if it already exists, is never cleaned up.
 * This endpoint can return a 404 for an event that no longer exists due to clean-up.
 */
export const getClusterEvent = <ThrowOnError extends boolean = false>(
  options: Options<GetClusterEventData, ThrowOnError>
) =>
  (options.client ?? client).get<GetClusterEventResponses, GetClusterEventErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/cluster/events/{event_id}',
    ...options
  })

/**
 * Check Cluster Health
 *
 * Determine the latest cluster health via the latest cluster monitor event.
 */
export const getClusterHealth = <ThrowOnError extends boolean = false>(
  options?: Options<GetClusterHealthData, ThrowOnError>
) =>
  (options?.client ?? client).get<GetClusterHealthResponses, GetClusterHealthErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/cluster_healthz',
    ...options
  })

/**
 * Get Platform Config
 *
 * Retrieve configuration of the Feldera Platform.
 */
export const getConfig = <ThrowOnError extends boolean = false>(
  options?: Options<GetConfigData, ThrowOnError>
) =>
  (options?.client ?? client).get<GetConfigResponses, GetConfigErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/config',
    ...options
  })

/**
 * List Demos
 *
 * Retrieve the list of demos available in the WebConsole.
 */
export const getConfigDemos = <ThrowOnError extends boolean = false>(
  options?: Options<GetConfigDemosData, ThrowOnError>
) =>
  (options?.client ?? client).get<GetConfigDemosResponses, GetConfigDemosErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/config/demos',
    ...options
  })

/**
 * Get Session
 *
 * Retrieve login session information for your current user session.
 */
export const getConfigSession = <ThrowOnError extends boolean = false>(
  options?: Options<GetConfigSessionData, ThrowOnError>
) =>
  (options?.client ?? client).get<GetConfigSessionResponses, GetConfigSessionErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/config/session',
    ...options
  })

/**
 * List All Metrics
 *
 * Retrieve the metrics of all running pipelines belonging to this tenant.
 *
 * The metrics are collected by making individual HTTP requests to `/metrics`
 * endpoint of each pipeline, of which only successful responses are included
 * in the returned list.
 */
export const getMetrics = <ThrowOnError extends boolean = false>(
  options?: Options<GetMetricsData, ThrowOnError>
) =>
  (options?.client ?? client).get<GetMetricsResponses, unknown, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/metrics',
    ...options
  })

/**
 * List Pipelines
 *
 * Retrieve the list of pipelines.
 * Configure which fields are included using the `selector` query parameter.
 */
export const listPipelines = <ThrowOnError extends boolean = false>(
  options?: Options<ListPipelinesData, ThrowOnError>
) =>
  (options?.client ?? client).get<ListPipelinesResponses, ListPipelinesErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines',
    ...options
  })

/**
 * Create Pipeline
 *
 * Create a new pipeline with the provided configuration.
 */
export const postPipeline = <ThrowOnError extends boolean = false>(
  options: Options<PostPipelineData, ThrowOnError>
) =>
  (options.client ?? client).post<PostPipelineResponses, PostPipelineErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers
    }
  })

/**
 * Delete Pipeline
 *
 * Delete an existing pipeline by name.
 */
export const deletePipeline = <ThrowOnError extends boolean = false>(
  options: Options<DeletePipelineData, ThrowOnError>
) =>
  (options.client ?? client).delete<DeletePipelineResponses, DeletePipelineErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}',
    ...options
  })

/**
 * Get Pipeline
 *
 * Retrieve a pipeline.
 * Configure which fields are included using the `selector` query parameter.
 */
export const getPipeline = <ThrowOnError extends boolean = false>(
  options: Options<GetPipelineData, ThrowOnError>
) =>
  (options.client ?? client).get<GetPipelineResponses, GetPipelineErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}',
    ...options
  })

/**
 * Patch Pipeline
 *
 * Partially update a pipeline.
 */
export const patchPipeline = <ThrowOnError extends boolean = false>(
  options: Options<PatchPipelineData, ThrowOnError>
) =>
  (options.client ?? client).patch<PatchPipelineResponses, PatchPipelineErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers
    }
  })

/**
 * Upsert Pipeline
 *
 * Fully update a pipeline if it already exists, otherwise create a new pipeline.
 */
export const putPipeline = <ThrowOnError extends boolean = false>(
  options: Options<PutPipelineData, ThrowOnError>
) =>
  (options.client ?? client).put<PutPipelineResponses, PutPipelineErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}',
    ...options,
    headers: {
      'Content-Type': 'application/json',
      ...options.headers
    }
  })

/**
 * Activate Standby Pipeline
 *
 * Requests the pipeline to activate if it is currently in standby mode, which it will do
 * asynchronously.
 *
 * Progress should be monitored by polling the pipeline `GET` endpoints.
 *
 * This endpoint is only applicable when the pipeline is configured to start
 * from object store and started as standby.
 */
export const postPipelineActivate = <ThrowOnError extends boolean = false>(
  options: Options<PostPipelineActivateData, ThrowOnError>
) =>
  (options.client ?? client).post<
    PostPipelineActivateResponses,
    PostPipelineActivateErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/activate',
    ...options
  })

/**
 * Approve Bootstrap
 *
 * Approves the pipeline to proceed with bootstrapping.
 *
 * This endpoint is used when a pipeline has been started with
 * `bootstrap_policy=await_approval`, it is resuming from an existing checkpoint,
 * but the pipeline has been modified since the checkpoint was made and is
 * currently in the `AwaitingApproval` state awaiting user approval to proceed
 * with bootstrapping.
 */
export const postPipelineApprove = <ThrowOnError extends boolean = false>(
  options: Options<PostPipelineApproveData, ThrowOnError>
) =>
  (options.client ?? client).post<
    PostPipelineApproveResponses,
    PostPipelineApproveErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/approve',
    ...options
  })

/**
 * Checkpoint Now
 *
 * Initiates checkpoint for a running or paused pipeline.
 *
 * Returns a checkpoint sequence number that can be used with `/checkpoint_status` to
 * determine when the checkpoint has completed.
 */
export const checkpointPipeline = <ThrowOnError extends boolean = false>(
  options: Options<CheckpointPipelineData, ThrowOnError>
) =>
  (options.client ?? client).post<
    CheckpointPipelineResponses,
    CheckpointPipelineErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/checkpoint',
    ...options
  })

/**
 * Sync Checkpoints To S3
 *
 * Syncs latest checkpoints to the object store configured in pipeline config.
 */
export const syncCheckpoint = <ThrowOnError extends boolean = false>(
  options: Options<SyncCheckpointData, ThrowOnError>
) =>
  (options.client ?? client).post<SyncCheckpointResponses, SyncCheckpointErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/checkpoint/sync',
    ...options
  })

/**
 * Get Checkpoint Sync Status
 *
 * Retrieve status of checkpoint sync activity in a pipeline.
 */
export const getCheckpointSyncStatus = <ThrowOnError extends boolean = false>(
  options: Options<GetCheckpointSyncStatusData, ThrowOnError>
) =>
  (options.client ?? client).get<
    GetCheckpointSyncStatusResponses,
    GetCheckpointSyncStatusErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/checkpoint/sync_status',
    ...options
  })

/**
 * Get Checkpoint Status
 *
 * Retrieve status of checkpoint activity in a pipeline.
 */
export const getCheckpointStatus = <ThrowOnError extends boolean = false>(
  options: Options<GetCheckpointStatusData, ThrowOnError>
) =>
  (options.client ?? client).get<
    GetCheckpointStatusResponses,
    GetCheckpointStatusErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/checkpoint_status',
    ...options
  })

/**
 * Performance Profile JSON
 *
 * Retrieve the circuit performance profile in JSON format of a running or paused pipeline.
 */
export const getPipelineCircuitJsonProfile = <ThrowOnError extends boolean = false>(
  options: Options<GetPipelineCircuitJsonProfileData, ThrowOnError>
) =>
  (options.client ?? client).get<
    GetPipelineCircuitJsonProfileResponses,
    GetPipelineCircuitJsonProfileErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/circuit_json_profile',
    ...options
  })

/**
 * Get Performance Profile
 *
 * Retrieve the circuit performance profile of a running or paused pipeline.
 */
export const getPipelineCircuitProfile = <ThrowOnError extends boolean = false>(
  options: Options<GetPipelineCircuitProfileData, ThrowOnError>
) =>
  (options.client ?? client).get<
    GetPipelineCircuitProfileResponses,
    GetPipelineCircuitProfileErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/circuit_profile',
    ...options
  })

/**
 * Clear Storage
 *
 * Clears the pipeline storage asynchronously.
 *
 * IMPORTANT: Clearing means disassociating the storage from the pipeline.
 * Depending on the storage type this can include its deletion.
 *
 * It sets the storage state to `Clearing`, after which the clearing process is
 * performed asynchronously. Progress should be monitored by polling the pipeline
 * using the `GET` endpoints. An `/clear` cannot be cancelled.
 */
export const postPipelineClear = <ThrowOnError extends boolean = false>(
  options: Options<PostPipelineClearData, ThrowOnError>
) =>
  (options.client ?? client).post<
    PostPipelineClearResponses,
    PostPipelineClearErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/clear',
    ...options
  })

/**
 * Commit Transaction
 *
 * Commit the current transaction.
 */
export const commitTransaction = <ThrowOnError extends boolean = false>(
  options: Options<CommitTransactionData, ThrowOnError>
) =>
  (options.client ?? client).post<
    CommitTransactionResponses,
    CommitTransactionErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/commit_transaction',
    ...options
  })

/**
 * Check Completion Status
 *
 * Check the status of a completion token returned by the `/ingress` or `/completion_token`
 * endpoint.
 */
export const completionStatus = <ThrowOnError extends boolean = false>(
  options: Options<CompletionStatusData, ThrowOnError>
) =>
  (options.client ?? client).get<CompletionStatusResponses, CompletionStatusErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/completion_status',
    ...options
  })

/**
 * Get Dataflow Graph
 *
 * Retrieve the dataflow graph of a pipeline.
 * The dataflow graph is generated during SQL compilation and shows the structure
 * of the compiled SQL program including the Calcite plan and MIR nodes.
 */
export const getPipelineDataflowGraph = <ThrowOnError extends boolean = false>(
  options: Options<GetPipelineDataflowGraphData, ThrowOnError>
) =>
  (options.client ?? client).get<
    GetPipelineDataflowGraphResponses,
    GetPipelineDataflowGraphErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/dataflow_graph',
    ...options
  })

/**
 * Subscribe to View
 *
 * Subscribe to a stream of updates from a SQL view or table.
 *
 * The pipeline responds with a continuous stream of changes to the specified
 * table or view, encoded using the format specified in the `?format=`
 * parameter. Updates are split into `Chunk`s.
 *
 * The pipeline continues sending updates until the client closes the
 * connection or the pipeline is stopped.
 */
export const httpOutput = <ThrowOnError extends boolean = false>(
  options: Options<HttpOutputData, ThrowOnError>
) =>
  (options.client ?? client).post<HttpOutputResponses, HttpOutputErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/egress/{table_name}',
    ...options
  })

/**
 * Get Heap Profile
 *
 * Retrieve the heap profile of a running or paused pipeline.
 */
export const getPipelineHeapProfile = <ThrowOnError extends boolean = false>(
  options: Options<GetPipelineHeapProfileData, ThrowOnError>
) =>
  (options.client ?? client).get<
    GetPipelineHeapProfileResponses,
    GetPipelineHeapProfileErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/heap_profile',
    ...options
  })

/**
 * Insert Data
 *
 * Push data to a SQL table.
 *
 * The client sends data encoded using the format specified in the `?format=`
 * parameter as a body of the request.  The contents of the data must match
 * the SQL table schema specified in `table_name`
 *
 * The pipeline ingests data as it arrives without waiting for the end of
 * the request.  Successful HTTP response indicates that all data has been
 * ingested successfully.
 *
 * On success, returns a completion token that can be passed to the
 * '/completion_status' endpoint to check whether the pipeline has fully
 * processed the data.
 */
export const httpInput = <ThrowOnError extends boolean = false>(
  options: Options<HttpInputData, ThrowOnError>
) =>
  (options.client ?? client).post<HttpInputResponses, HttpInputErrors, ThrowOnError>({
    bodySerializer: null,
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/ingress/{table_name}',
    ...options,
    headers: {
      'Content-Type': 'text/plain',
      ...options.headers
    }
  })

/**
 * Stream Pipeline Logs
 *
 * Retrieve logs of a pipeline as a stream.
 *
 * The logs stream catches up to the extent of the internally configured per-pipeline
 * circular logs buffer (limited to a certain byte size and number of lines, whichever
 * is reached first). After the catch-up, new lines are pushed whenever they become
 * available.
 *
 * It is possible for the logs stream to end prematurely due to the API server temporarily losing
 * connection to the runner. In this case, it is needed to issue again a new request to this
 * endpoint.
 *
 * The logs stream will end when the pipeline is deleted, or if the runner restarts. Note that in
 * both cases the logs will be cleared.
 */
export const getPipelineLogs = <ThrowOnError extends boolean = false>(
  options: Options<GetPipelineLogsData, ThrowOnError>
) =>
  (options.client ?? client).get<GetPipelineLogsResponses, GetPipelineLogsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/logs',
    ...options
  })

/**
 * Get Pipeline Metrics
 *
 * Retrieve the metrics of a running or paused pipeline.
 */
export const getPipelineMetrics = <ThrowOnError extends boolean = false>(
  options: Options<GetPipelineMetricsData, ThrowOnError>
) =>
  (options.client ?? client).get<
    GetPipelineMetricsResponses,
    GetPipelineMetricsErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/metrics',
    ...options
  })

/**
 * Pause Pipeline
 *
 * Requests the pipeline to pause, which it will do asynchronously.
 *
 * Progress should be monitored by polling the pipeline `GET` endpoints.
 */
export const postPipelinePause = <ThrowOnError extends boolean = false>(
  options: Options<PostPipelinePauseData, ThrowOnError>
) =>
  (options.client ?? client).post<
    PostPipelinePauseResponses,
    PostPipelinePauseErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/pause',
    ...options
  })

/**
 * Execute Ad-hoc SQL
 *
 * Execute ad-hoc SQL in a running or paused pipeline.
 *
 * The evaluation is not incremental.
 */
export const pipelineAdhocSql = <ThrowOnError extends boolean = false>(
  options: Options<PipelineAdhocSqlData, ThrowOnError>
) =>
  (options.client ?? client).get<PipelineAdhocSqlResponses, PipelineAdhocSqlErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/query',
    ...options
  })

/**
 * Initiate rebalancing.
 *
 * Initiate immediate rebalancing of the pipeline. Normally rebalancing is initiated automatically
 * when the drift in the size of joined relations exceeds a threshold. This endpoint forces the balancer
 * to reevaluate and apply an optimal partitioning policy regardless of the threshold.
 *
 * This operation is a no-op unless the `adaptive_joins` feature is enabled in `dev_tweaks`.
 */
export const postPipelineRebalance = <ThrowOnError extends boolean = false>(
  options: Options<PostPipelineRebalanceData, ThrowOnError>
) =>
  (options.client ?? client).post<
    PostPipelineRebalanceResponses,
    PostPipelineRebalanceErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/rebalance',
    ...options
  })

/**
 * Resume Pipeline
 *
 * Requests the pipeline to resume, which it will do asynchronously.
 *
 * Progress should be monitored by polling the pipeline `GET` endpoints.
 */
export const postPipelineResume = <ThrowOnError extends boolean = false>(
  options: Options<PostPipelineResumeData, ThrowOnError>
) =>
  (options.client ?? client).post<
    PostPipelineResumeResponses,
    PostPipelineResumeErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/resume',
    ...options
  })

/**
 * Get Samply Profile
 *
 * Retrieve the last samply profile of a pipeline, regardless of whether profiling is currently in progress.
 * If ?latest parameter is specified and Samply profile collection is in progress, returns HTTP 307 with Retry-After header.
 */
export const getPipelineSamplyProfile = <ThrowOnError extends boolean = false>(
  options: Options<GetPipelineSamplyProfileData, ThrowOnError>
) =>
  (options.client ?? client).get<
    GetPipelineSamplyProfileResponses,
    GetPipelineSamplyProfileErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/samply_profile',
    ...options
  })

/**
 * Start a Samply profile
 *
 * Profile the pipeline using the Samply profiler for the next `duration_secs` seconds.
 */
export const startSamplyProfile = <ThrowOnError extends boolean = false>(
  options: Options<StartSamplyProfileData, ThrowOnError>
) =>
  (options.client ?? client).post<
    StartSamplyProfileResponses,
    StartSamplyProfileErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/samply_profile',
    ...options
  })

/**
 * Start Pipeline
 *
 * Start the pipeline asynchronously by updating the desired status.
 *
 * The endpoint returns immediately after setting the desired status.
 * The procedure to get to the desired status is performed asynchronously.
 * Progress should be monitored by polling the pipeline `GET` endpoints.
 *
 * Note the following:
 * - A stopped pipeline can be started through calling `/start?initial=running`,
 * `/start?initial=paused`, or `/start?initial=standby`.
 * - If the pipeline is already (being) started (provisioned), it will still return success
 * - It is not possible to call `/start` when the pipeline has already had `/stop` called and is
 * in the process of suspending or stopping.
 */
export const postPipelineStart = <ThrowOnError extends boolean = false>(
  options: Options<PostPipelineStartData, ThrowOnError>
) =>
  (options.client ?? client).post<
    PostPipelineStartResponses,
    PostPipelineStartErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/start',
    ...options
  })

/**
 * Begin Transaction
 *
 * Start a new transaction.
 */
export const startTransaction = <ThrowOnError extends boolean = false>(
  options: Options<StartTransactionData, ThrowOnError>
) =>
  (options.client ?? client).post<StartTransactionResponses, StartTransactionErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/start_transaction',
    ...options
  })

/**
 * Get Pipeline Stats
 *
 * Retrieve statistics (e.g., performance counters) of a running or paused pipeline.
 */
export const getPipelineStats = <ThrowOnError extends boolean = false>(
  options: Options<GetPipelineStatsData, ThrowOnError>
) =>
  (options.client ?? client).get<GetPipelineStatsResponses, GetPipelineStatsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/stats',
    ...options
  })

/**
 * Stop Pipeline
 *
 * Stop the pipeline asynchronously by updating the desired state.
 *
 * There are two variants:
 * - `/stop?force=false` (default): the pipeline will first atomically checkpoint before
 * deprovisioning the compute resources. When resuming, the pipeline will start from this
 * - `/stop?force=true`: the compute resources will be immediately deprovisioned. When resuming,
 * it will pick up the latest checkpoint made by the periodic checkpointer or by a prior
 * `/checkpoint` call.
 *
 * The endpoint returns immediately after setting the desired state to `Suspended` for
 * `?force=false` or `Stopped` for `?force=true`. In the former case, once the pipeline has
 * successfully passes the `Suspending` state, the desired state will become `Stopped` as well.
 * The procedure to get to the desired state is performed asynchronously. Progress should be
 * monitored by polling the pipeline `GET` endpoints.
 *
 * Note the following:
 * - The suspending that is done with `/stop?force=false` is not guaranteed to succeed:
 * - If an error is returned during the suspension, the pipeline will be forcefully stopped with
 * that error set
 * - Otherwise, it will keep trying to suspend, in which case it is possible to cancel suspending
 * by calling `/stop?force=true`
 * - `/stop?force=true` cannot be cancelled: the pipeline must first reach `Stopped` before another
 * action can be done
 * - A pipeline which is in the process of suspending or stopping can only be forcefully stopped
 */
export const postPipelineStop = <ThrowOnError extends boolean = false>(
  options: Options<PostPipelineStopData, ThrowOnError>
) =>
  (options.client ?? client).post<PostPipelineStopResponses, PostPipelineStopErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/stop',
    ...options
  })

/**
 * Download Support Bundle
 *
 * Generate a support bundle for a pipeline.
 *
 * This endpoint collects various diagnostic data from the pipeline including
 * circuit profile, heap profile, metrics, logs, stats, and connector statistics,
 * and packages them into a single ZIP file for support purposes.
 */
export const getPipelineSupportBundle = <ThrowOnError extends boolean = false>(
  options: Options<GetPipelineSupportBundleData, ThrowOnError>
) =>
  (options.client ?? client).get<
    GetPipelineSupportBundleResponses,
    GetPipelineSupportBundleErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/support_bundle',
    ...options
  })

/**
 * Get Completion Token
 *
 * Generate a completion token for an input connector.
 *
 * Returns a token that can be passed to the `/completion_status` endpoint
 * to check whether the pipeline has finished processing all inputs received from the
 * connector before the token was generated.
 */
export const completionToken = <ThrowOnError extends boolean = false>(
  options: Options<CompletionTokenData, ThrowOnError>
) =>
  (options.client ?? client).get<CompletionTokenResponses, CompletionTokenErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/tables/{table_name}/connectors/{connector_name}/completion_token',
    ...options
  })

/**
 * Get Input Status
 *
 * Retrieve the status of an input connector.
 */
export const getPipelineInputConnectorStatus = <ThrowOnError extends boolean = false>(
  options: Options<GetPipelineInputConnectorStatusData, ThrowOnError>
) =>
  (options.client ?? client).get<
    GetPipelineInputConnectorStatusResponses,
    GetPipelineInputConnectorStatusErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/tables/{table_name}/connectors/{connector_name}/stats',
    ...options
  })

/**
 * Control Input Connector
 *
 * Start (resume) or pause the input connector.
 *
 * The following values of the `action` argument are accepted: `start` and `pause`.
 *
 * Input connectors can be in either the `Running` or `Paused` state. By default,
 * connectors are initialized in the `Running` state when a pipeline is deployed.
 * In this state, the connector actively fetches data from its configured data
 * source and forwards it to the pipeline. If needed, a connector can be created
 * in the `Paused` state by setting its
 * [`paused`](https://docs.feldera.com/connectors/#generic-attributes) property
 * to `true`. When paused, the connector remains idle until reactivated using the
 * `start` command. Conversely, a connector in the `Running` state can be paused
 * at any time by issuing the `pause` command.
 *
 * The current connector state can be retrieved via the
 * `GET /v0/pipelines/{pipeline_name}/stats` endpoint.
 *
 * Note that only if both the pipeline *and* the connector state is `Running`,
 * is the input connector active.
 * ```text
 * Pipeline state    Connector state    Connector is active?
 * --------------    ---------------    --------------------
 * Paused            Paused             No
 * Paused            Running            No
 * Running           Paused             No
 * Running           Running            Yes
 * ```
 */
export const postPipelineInputConnectorAction = <ThrowOnError extends boolean = false>(
  options: Options<PostPipelineInputConnectorActionData, ThrowOnError>
) =>
  (options.client ?? client).post<
    PostPipelineInputConnectorActionResponses,
    PostPipelineInputConnectorActionErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/tables/{table_name}/connectors/{connector_name}/{action}',
    ...options
  })

/**
 * Test Endpoint
 *
 * This endpoint is used as part of the test harness. Only available if the `testing`
 * unstable feature is enabled. Do not use in production.
 */
export const postPipelineTesting = <ThrowOnError extends boolean = false>(
  options: Options<PostPipelineTestingData, ThrowOnError>
) =>
  (options.client ?? client).post<
    PostPipelineTestingResponses,
    PostPipelineTestingErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/testing',
    ...options
  })

/**
 * Get Time Series Stats
 *
 * Retrieve time series for statistics of a running or paused pipeline.
 */
export const getPipelineTimeSeries = <ThrowOnError extends boolean = false>(
  options: Options<GetPipelineTimeSeriesData, ThrowOnError>
) =>
  (options.client ?? client).get<
    GetPipelineTimeSeriesResponses,
    GetPipelineTimeSeriesErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/time_series',
    ...options
  })

/**
 * Stream Time Series
 *
 * Stream time series for statistics of a running or paused pipeline.
 *
 * Returns a snapshot of all existing time series data followed by a continuous stream of
 * new time series data points as they become available. The response is in newline-delimited
 * JSON format (NDJSON) where each line is a JSON object representing a single time series
 * data point.
 */
export const getPipelineTimeSeriesStream = <ThrowOnError extends boolean = false>(
  options: Options<GetPipelineTimeSeriesStreamData, ThrowOnError>
) =>
  (options.client ?? client).get<
    GetPipelineTimeSeriesStreamResponses,
    GetPipelineTimeSeriesStreamErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/time_series_stream',
    ...options
  })

/**
 * Recompile Pipeline
 *
 * Recompile a pipeline with the Feldera runtime version included in the
 * currently installed Feldera platform.
 *
 * Use this endpoint after upgrading Feldera to rebuild pipelines that were
 * compiled with older platform versions. In most cases, recompilation is not
 * required; pipelines compiled with older versions will continue to run on the
 * upgraded platform.
 *
 * Situations where recompilation may be necessary:
 * - To benefit from the latest bug fixes and performance optimizations.
 * - When backward-incompatible changes are introduced in Feldera. In this case,
 * attempting to start a pipeline compiled with an unsupported version will
 * result in an error.
 *
 * If the pipeline is already compiled with the current platform version,
 * this operation is a no-op.
 *
 * Note that recompiling the pipeline with a new platform version may change its
 * query plan. If the modified pipeline is started from an existing checkpoint,
 * it may require bootstrapping parts of its state from scratch.  See Feldera
 * documentation for details on the bootstrapping process.
 */
export const postUpdateRuntime = <ThrowOnError extends boolean = false>(
  options: Options<PostUpdateRuntimeData, ThrowOnError>
) =>
  (options.client ?? client).post<
    PostUpdateRuntimeResponses,
    PostUpdateRuntimeErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/update_runtime',
    ...options
  })

/**
 * Get Output Status
 *
 * Retrieve the status of an output connector.
 */
export const getPipelineOutputConnectorStatus = <ThrowOnError extends boolean = false>(
  options: Options<GetPipelineOutputConnectorStatusData, ThrowOnError>
) =>
  (options.client ?? client).get<
    GetPipelineOutputConnectorStatusResponses,
    GetPipelineOutputConnectorStatusErrors,
    ThrowOnError
  >({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/v0/pipelines/{pipeline_name}/views/{view_name}/connectors/{connector_name}/stats',
    ...options
  })
