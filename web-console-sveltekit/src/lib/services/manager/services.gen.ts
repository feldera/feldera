// This file is auto-generated by @hey-api/openapi-ts

import { client, type Options } from '@hey-api/client-fetch'
import type {
  GetAuthenticationConfigError,
  GetAuthenticationConfigResponse,
  ListApiKeysData,
  ListApiKeysError,
  ListApiKeysResponse,
  CreateApiKeyData,
  CreateApiKeyError,
  CreateApiKeyResponse,
  GetApiKeyData,
  GetApiKeyError,
  GetApiKeyResponse,
  DeleteApiKeyData,
  DeleteApiKeyError,
  DeleteApiKeyResponse,
  GetDemosError,
  GetDemosResponse,
  ListConnectorsData,
  ListConnectorsError,
  ListConnectorsResponse,
  NewConnectorData,
  NewConnectorError,
  NewConnectorResponse2,
  GetConnectorData,
  GetConnectorError,
  GetConnectorResponse,
  CreateOrReplaceConnectorData,
  CreateOrReplaceConnectorError,
  CreateOrReplaceConnectorResponse2,
  DeleteConnectorData,
  DeleteConnectorError,
  DeleteConnectorResponse,
  UpdateConnectorData,
  UpdateConnectorError,
  UpdateConnectorResponse2,
  ListPipelinesData,
  ListPipelinesError,
  ListPipelinesResponse,
  NewPipelineData,
  NewPipelineError,
  NewPipelineResponse2,
  GetPipelineData,
  GetPipelineError,
  GetPipelineResponse,
  CreateOrReplacePipelineData,
  CreateOrReplacePipelineError,
  CreateOrReplacePipelineResponse2,
  PipelineDeleteData,
  PipelineDeleteError,
  PipelineDeleteResponse,
  UpdatePipelineData,
  UpdatePipelineError,
  UpdatePipelineResponse2,
  GetPipelineConfigData,
  GetPipelineConfigError,
  GetPipelineConfigResponse,
  PipelineDeployedData,
  PipelineDeployedError,
  PipelineDeployedResponse,
  DumpProfileData,
  DumpProfileError,
  DumpProfileResponse,
  HttpOutputData,
  HttpOutputError,
  HttpOutputResponse,
  HeapProfileData,
  HeapProfileError,
  HeapProfileResponse,
  HttpInputData,
  HttpInputError,
  HttpInputResponse,
  PipelineStatsData,
  PipelineStatsError,
  PipelineStatsResponse,
  PipelineValidateData,
  PipelineValidateError,
  PipelineValidateResponse,
  PipelineActionData,
  PipelineActionError,
  PipelineActionResponse,
  GetProgramsData,
  GetProgramsError,
  GetProgramsResponse,
  NewProgramData,
  NewProgramError,
  NewProgramResponse2,
  GetProgramData,
  GetProgramError,
  GetProgramResponse,
  CreateOrReplaceProgramData,
  CreateOrReplaceProgramError,
  CreateOrReplaceProgramResponse2,
  DeleteProgramData,
  DeleteProgramError,
  DeleteProgramResponse,
  UpdateProgramData,
  UpdateProgramError,
  UpdateProgramResponse2,
  CompileProgramData,
  CompileProgramError,
  CompileProgramResponse,
  ListServicesData,
  ListServicesError,
  ListServicesResponse,
  NewServiceData,
  NewServiceError,
  NewServiceResponse2,
  GetServiceData,
  GetServiceError,
  GetServiceResponse,
  DeleteServiceData,
  DeleteServiceError,
  DeleteServiceResponse,
  UpdateServiceData,
  UpdateServiceError,
  UpdateServiceResponse2,
  ListServiceProbesData,
  ListServiceProbesError,
  ListServiceProbesResponse,
  NewServiceProbeData,
  NewServiceProbeError,
  NewServiceProbeResponse
} from './types.gen'

/**
 * Get authentication provider configuration
 */
export const getAuthenticationConfig = (options?: Options) => {
  return (options?.client ?? client).get<
    GetAuthenticationConfigResponse,
    GetAuthenticationConfigError
  >({
    ...options,
    url: '/config/authentication'
  })
}

/**
 * List all API keys
 */
export const listApiKeys = (options?: Options<ListApiKeysData>) => {
  return (options?.client ?? client).get<ListApiKeysResponse, ListApiKeysError>({
    ...options,
    url: '/v0/api_keys'
  })
}

/**
 * Create an API key
 */
export const createApiKey = (options: Options<CreateApiKeyData>) => {
  return (options?.client ?? client).post<CreateApiKeyResponse, CreateApiKeyError>({
    ...options,
    url: '/v0/api_keys'
  })
}

/**
 * Get an API key description
 */
export const getApiKey = (options: Options<GetApiKeyData>) => {
  return (options?.client ?? client).get<GetApiKeyResponse, GetApiKeyError>({
    ...options,
    url: '/v0/api_keys/{api_key_name}'
  })
}

/**
 * Delete an API key
 */
export const deleteApiKey = (options: Options<DeleteApiKeyData>) => {
  return (options?.client ?? client).delete<DeleteApiKeyResponse, DeleteApiKeyError>({
    ...options,
    url: '/v0/api_keys/{api_key_name}'
  })
}

/**
 * Get the list of demo URLs.
 */
export const getDemos = (options?: Options) => {
  return (options?.client ?? client).get<GetDemosResponse, GetDemosError>({
    ...options,
    url: '/v0/config/demos'
  })
}

/**
 * Fetch connectors, optionally filtered by name or ID
 */
export const listConnectors = (options?: Options<ListConnectorsData>) => {
  return (options?.client ?? client).get<ListConnectorsResponse, ListConnectorsError>({
    ...options,
    url: '/v0/connectors'
  })
}

/**
 * Create a new connector.
 */
export const newConnector = (options: Options<NewConnectorData>) => {
  return (options?.client ?? client).post<NewConnectorResponse2, NewConnectorError>({
    ...options,
    url: '/v0/connectors'
  })
}

/**
 * Fetch a connector by name.
 */
export const getConnector = (options: Options<GetConnectorData>) => {
  return (options?.client ?? client).get<GetConnectorResponse, GetConnectorError>({
    ...options,
    url: '/v0/connectors/{connector_name}'
  })
}

/**
 * Create or replace a connector.
 */
export const createOrReplaceConnector = (options: Options<CreateOrReplaceConnectorData>) => {
  return (options?.client ?? client).put<
    CreateOrReplaceConnectorResponse2,
    CreateOrReplaceConnectorError
  >({
    ...options,
    url: '/v0/connectors/{connector_name}'
  })
}

/**
 * Delete an existing connector.
 */
export const deleteConnector = (options: Options<DeleteConnectorData>) => {
  return (options?.client ?? client).delete<DeleteConnectorResponse, DeleteConnectorError>({
    ...options,
    url: '/v0/connectors/{connector_name}'
  })
}

/**
 * Update the name, description and/or configuration of a connector.
 */
export const updateConnector = (options: Options<UpdateConnectorData>) => {
  return (options?.client ?? client).patch<UpdateConnectorResponse2, UpdateConnectorError>({
    ...options,
    url: '/v0/connectors/{connector_name}'
  })
}

/**
 * Fetch pipelines, optionally filtered by name or ID.
 */
export const listPipelines = (options?: Options<ListPipelinesData>) => {
  return (options?.client ?? client).get<ListPipelinesResponse, ListPipelinesError>({
    ...options,
    url: '/v0/pipelines'
  })
}

/**
 * Create a new pipeline.
 */
export const newPipeline = (options: Options<NewPipelineData>) => {
  return (options?.client ?? client).post<NewPipelineResponse2, NewPipelineError>({
    ...options,
    url: '/v0/pipelines'
  })
}

/**
 * Fetch a pipeline by ID.
 */
export const getPipeline = (options: Options<GetPipelineData>) => {
  return (options?.client ?? client).get<GetPipelineResponse, GetPipelineError>({
    ...options,
    url: '/v0/pipelines/{pipeline_name}'
  })
}

/**
 * Create or replace a pipeline.
 */
export const createOrReplacePipeline = (options: Options<CreateOrReplacePipelineData>) => {
  return (options?.client ?? client).put<
    CreateOrReplacePipelineResponse2,
    CreateOrReplacePipelineError
  >({
    ...options,
    url: '/v0/pipelines/{pipeline_name}'
  })
}

/**
 * Delete a pipeline. The pipeline must be in the shutdown state.
 */
export const pipelineDelete = (options: Options<PipelineDeleteData>) => {
  return (options?.client ?? client).delete<PipelineDeleteResponse, PipelineDeleteError>({
    ...options,
    url: '/v0/pipelines/{pipeline_name}'
  })
}

/**
 * Change a pipeline's name, description, code, configuration, or connectors.
 * On success, increments the pipeline's version by 1.
 */
export const updatePipeline = (options: Options<UpdatePipelineData>) => {
  return (options?.client ?? client).patch<UpdatePipelineResponse2, UpdatePipelineError>({
    ...options,
    url: '/v0/pipelines/{pipeline_name}'
  })
}

/**
 * Fetch a pipeline's configuration.
 * When defining a pipeline, clients have to provide an optional
 * `RuntimeConfig` for the pipelines and references to existing
 * connectors to attach to the pipeline. This endpoint retrieves
 * the *expanded* definition of the pipeline's configuration,
 * which comprises both the `RuntimeConfig` and the complete
 * definitions of the attached connectors.
 */
export const getPipelineConfig = (options: Options<GetPipelineConfigData>) => {
  return (options?.client ?? client).get<GetPipelineConfigResponse, GetPipelineConfigError>({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/config'
  })
}

/**
 * Return the currently deployed version of the pipeline, if any.
 */
export const pipelineDeployed = (options: Options<PipelineDeployedData>) => {
  return (options?.client ?? client).get<PipelineDeployedResponse, PipelineDeployedError>({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/deployed'
  })
}

/**
 * Initiate profile dump.
 */
export const dumpProfile = (options: Options<DumpProfileData>) => {
  return (options?.client ?? client).get<DumpProfileResponse, DumpProfileError>({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/dump_profile'
  })
}

/**
 * Subscribe to a stream of updates from a SQL view or table.
 * The pipeline responds with a continuous stream of changes to the specified
 * table or view, encoded using the format specified in the `?format=`
 * parameter. Updates are split into `Chunk`s.
 *
 * The pipeline continues sending updates until the client closes the
 * connection or the pipeline is shut down.
 *
 * This API is a POST instead of a GET, because when performing neighborhood
 * queries (query='neighborhood'), the call expects a request body which
 * contains, among other things, a full row to execute a neighborhood search
 * around. A row can be quite large and is not appropriate as a query
 * parameter.
 */
export const httpOutput = (options: Options<HttpOutputData>) => {
  return (options?.client ?? client).post<HttpOutputResponse, HttpOutputError>({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/egress/{table_name}'
  })
}

/**
 * Retrieve heap profile of the pipeline.
 */
export const heapProfile = (options: Options<HeapProfileData>) => {
  return (options?.client ?? client).get<HeapProfileResponse, HeapProfileError>({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/heap_profile'
  })
}

/**
 * Push data to a SQL table.
 * The client sends data encoded using the format specified in the `?format=`
 * parameter as a body of the request.  The contents of the data must match
 * the SQL table schema specified in `table_name`
 *
 * The pipeline ingests data as it arrives without waiting for the end of
 * the request.  Successful HTTP response indicates that all data has been
 * ingested successfully.
 */
export const httpInput = (options: Options<HttpInputData>) => {
  return (options?.client ?? client).post<HttpInputResponse, HttpInputError>({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/ingress/{table_name}'
  })
}

/**
 * Retrieve pipeline metrics and performance counters.
 */
export const pipelineStats = (options: Options<PipelineStatsData>) => {
  return (options?.client ?? client).get<PipelineStatsResponse, PipelineStatsError>({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/stats'
  })
}

/**
 * Validate a pipeline.
 * Checks whether a pipeline is configured correctly. This includes
 * checking whether the pipeline references a valid compiled program,
 * whether the connectors reference valid tables/views in the program,
 * and more.
 */
export const pipelineValidate = (options: Options<PipelineValidateData>) => {
  return (options?.client ?? client).get<PipelineValidateResponse, PipelineValidateError>({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/validate'
  })
}

/**
 * Change the desired state of the pipeline.
 * This endpoint allows the user to control the execution of the pipeline,
 * by changing its desired state attribute (see the discussion of the desired
 * state model in the [`PipelineStatus`] documentation).
 *
 * The endpoint returns immediately after validating the request and forwarding
 * it to the pipeline. The requested status change completes asynchronously.
 * On success, the pipeline enters the requested desired state.  On error, the
 * pipeline transitions to the `Failed` state. The user
 * can monitor the current status of the pipeline by polling the `GET
 * /pipeline` endpoint.
 *
 * The following values of the `action` argument are accepted by this endpoint:
 *
 * - 'start': Start processing data.
 * - 'pause': Pause the pipeline.
 * - 'shutdown': Terminate the execution of the pipeline.
 */
export const pipelineAction = (options: Options<PipelineActionData>) => {
  return (options?.client ?? client).post<PipelineActionResponse, PipelineActionError>({
    ...options,
    url: '/v0/pipelines/{pipeline_name}/{action}'
  })
}

/**
 * Fetch programs, optionally filtered by name or ID.
 */
export const getPrograms = (options?: Options<GetProgramsData>) => {
  return (options?.client ?? client).get<GetProgramsResponse, GetProgramsError>({
    ...options,
    url: '/v0/programs'
  })
}

/**
 * Create a new program.
 */
export const newProgram = (options: Options<NewProgramData>) => {
  return (options?.client ?? client).post<NewProgramResponse2, NewProgramError>({
    ...options,
    url: '/v0/programs'
  })
}

/**
 * Fetch a program by name.
 */
export const getProgram = (options: Options<GetProgramData>) => {
  return (options?.client ?? client).get<GetProgramResponse, GetProgramError>({
    ...options,
    url: '/v0/programs/{program_name}'
  })
}

/**
 * Create or replace a program.
 */
export const createOrReplaceProgram = (options: Options<CreateOrReplaceProgramData>) => {
  return (options?.client ?? client).put<
    CreateOrReplaceProgramResponse2,
    CreateOrReplaceProgramError
  >({
    ...options,
    url: '/v0/programs/{program_name}'
  })
}

/**
 * Delete a program.
 * Deletion fails if there is at least one pipeline associated with the
 * program.
 */
export const deleteProgram = (options: Options<DeleteProgramData>) => {
  return (options?.client ?? client).delete<DeleteProgramResponse, DeleteProgramError>({
    ...options,
    url: '/v0/programs/{program_name}'
  })
}

/**
 * Change one or more of a program's code, description or name.
 * If a program's code changes, any ongoing compilation gets cancelled,
 * the program status is reset to `None`, and the program version
 * is incremented by 1.
 *
 * Changing only the program's name or description does not affect its
 * version or the compilation process.
 */
export const updateProgram = (options: Options<UpdateProgramData>) => {
  return (options?.client ?? client).patch<UpdateProgramResponse2, UpdateProgramError>({
    ...options,
    url: '/v0/programs/{program_name}'
  })
}

/**
 * Deprecated. Mark a program for compilation.
 * The client can track a program's compilation status by polling the
 * `/program/{program_name}` or `/programs` endpoints, and
 * then checking the `status` field of the program object.
 */
export const compileProgram = (options: Options<CompileProgramData>) => {
  return (options?.client ?? client).post<CompileProgramResponse, CompileProgramError>({
    ...options,
    url: '/v0/programs/{program_name}/compile'
  })
}

/**
 * Fetch services, optionally filtered by name, ID or configuration type.
 */
export const listServices = (options?: Options<ListServicesData>) => {
  return (options?.client ?? client).get<ListServicesResponse, ListServicesError>({
    ...options,
    url: '/v0/services'
  })
}

/**
 * Create a new service.
 */
export const newService = (options: Options<NewServiceData>) => {
  return (options?.client ?? client).post<NewServiceResponse2, NewServiceError>({
    ...options,
    url: '/v0/services'
  })
}

/**
 * Fetch a service by name.
 */
export const getService = (options: Options<GetServiceData>) => {
  return (options?.client ?? client).get<GetServiceResponse, GetServiceError>({
    ...options,
    url: '/v0/services/{service_name}'
  })
}

/**
 * Delete an existing service.
 */
export const deleteService = (options: Options<DeleteServiceData>) => {
  return (options?.client ?? client).delete<DeleteServiceResponse, DeleteServiceError>({
    ...options,
    url: '/v0/services/{service_name}'
  })
}

/**
 * Update the name, description and/or configuration of a service.
 */
export const updateService = (options: Options<UpdateServiceData>) => {
  return (options?.client ?? client).patch<UpdateServiceResponse2, UpdateServiceError>({
    ...options,
    url: '/v0/services/{service_name}'
  })
}

/**
 * Fetch a list of probes for a service, optionally filtered by id.
 */
export const listServiceProbes = (options: Options<ListServiceProbesData>) => {
  return (options?.client ?? client).get<ListServiceProbesResponse, ListServiceProbesError>({
    ...options,
    url: '/v0/services/{service_name}/probes'
  })
}

/**
 * Create a service probe.
 */
export const newServiceProbe = (options: Options<NewServiceProbeData>) => {
  return (options?.client ?? client).post<NewServiceProbeResponse, NewServiceProbeError>({
    ...options,
    url: '/v0/services/{service_name}/probes'
  })
}
